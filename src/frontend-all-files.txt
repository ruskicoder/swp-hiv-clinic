# Frontend Hierarchy and Source Files

## Hierarchy Structure

src/
â”œâ”€â”€ App.css
â”œâ”€â”€ App.jsx
â”œâ”€â”€ index.css
â”œâ”€â”€ index.jsx
â”œâ”€â”€ main.jsx
â”œâ”€â”€ StagewiseToolbarDevOnly.jsx
â”œâ”€â”€ frontend-all-files.txt
â”œâ”€â”€ assets/
â”œâ”€â”€ contexts/
â”‚   â”œâ”€â”€ AuthContext.jsx
â”‚   â”œâ”€â”€ useAuth.js
â”‚   â””â”€â”€ useSessionMonitor.js
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ Debug.jsx
â”‚   â”œâ”€â”€ ErrorBoundary.css
â”‚   â”œâ”€â”€ ErrorBoundary.jsx
â”‚   â”œâ”€â”€ PatientRecordSection.css
â”‚   â”œâ”€â”€ PatientRecordSection.jsx
â”‚   â”œâ”€â”€ arv/
â”‚   â”‚   â”œâ”€â”€ ARVTreatmentModal.css
â”‚   â”‚   â””â”€â”€ ARVTreatmentModal.jsx
â”‚   â”œâ”€â”€ layout/
â”‚   â”‚   â”œâ”€â”€ BackNavigation.css
â”‚   â”‚   â”œâ”€â”€ BackNavigation.jsx
â”‚   â”‚   â”œâ”€â”€ DashboardHeader.css
â”‚   â”‚   â”œâ”€â”€ DashboardHeader.jsx
â”‚   â”‚   â”œâ”€â”€ Footer.jsx
â”‚   â”‚   â”œâ”€â”€ Navbar.css
â”‚   â”‚   â”œâ”€â”€ Navbar.jsx
â”‚   â”‚   â”œâ”€â”€ UserProfileDropdown.css
â”‚   â”‚   â””â”€â”€ UserProfileDropdown.jsx
â”‚   â”œâ”€â”€ manager/
â”‚   â”‚   â””â”€â”€ ExportData.jsx
â”‚   â”œâ”€â”€ notifications/
â”‚   â”‚   â”œâ”€â”€ NotificationHistoryTable.css
â”‚   â”‚   â”œâ”€â”€ NotificationHistoryTable.jsx
â”‚   â”‚   â”œâ”€â”€ NotificationIcon.css
â”‚   â”‚   â”œâ”€â”€ NotificationIcon.jsx
â”‚   â”‚   â”œâ”€â”€ NotificationItem.css
â”‚   â”‚   â”œâ”€â”€ NotificationItem.jsx
â”‚   â”‚   â”œâ”€â”€ NotificationManagementDashboard.css
â”‚   â”‚   â”œâ”€â”€ NotificationManagementDashboard.jsx
â”‚   â”‚   â”œâ”€â”€ NotificationManagerTab.css
â”‚   â”‚   â”œâ”€â”€ NotificationManagerTab.jsx
â”‚   â”‚   â”œâ”€â”€ NotificationPanel.css
â”‚   â”‚   â”œâ”€â”€ NotificationPanel.jsx
â”‚   â”‚   â”œâ”€â”€ NotificationSendModal.css
â”‚   â”‚   â”œâ”€â”€ NotificationSendModal.jsx
â”‚   â”‚   â”œâ”€â”€ NotificationTemplateSelector.css
â”‚   â”‚   â”œâ”€â”€ NotificationTemplateSelector.jsx
â”‚   â”‚   â”œâ”€â”€ PatientSelector.css
â”‚   â”‚   â””â”€â”€ PatientSelector.jsx
â”‚   â”œâ”€â”€ schedule/
â”‚   â”‚   â”œâ”€â”€ AvailabilityCalendar.css
â”‚   â”‚   â”œâ”€â”€ AvailabilityCalendar.jsx
â”‚   â”‚   â”œâ”€â”€ SlotActionModal.css
â”‚   â”‚   â”œâ”€â”€ SlotActionModal.jsx
â”‚   â”‚   â”œâ”€â”€ SlotManagementModal.css
â”‚   â”‚   â”œâ”€â”€ SlotManagementModal.jsx
â”‚   â”‚   â”œâ”€â”€ TimeSlotModal.css
â”‚   â”‚   â”œâ”€â”€ TimeSlotModal.jsx
â”‚   â”‚   â”œâ”€â”€ UnifiedCalendar.css
â”‚   â”‚   â”œâ”€â”€ UnifiedCalendar.jsx
â”‚   â”‚   â”œâ”€â”€ WeeklySchedule.css
â”‚   â”‚   â””â”€â”€ WeeklySchedule.jsx
â”‚   â””â”€â”€ ui/
â”‚       â”œâ”€â”€ ProfileLoadingModal.css
â”‚       â”œâ”€â”€ ProfileLoadingModal.jsx
â”‚       â”œâ”€â”€ SessionTimeoutModal.css
â”‚       â””â”€â”€ SessionTimeoutModal.jsx
â”œâ”€â”€ features/
â”‚   â”œâ”€â”€ Admin/
â”‚   â”‚   â”œâ”€â”€ AdminDashboard.css
â”‚   â”‚   â””â”€â”€ AdminDashboard.jsx
â”‚   â”œâ”€â”€ auth/
â”‚   â”‚   â”œâ”€â”€ Auth.css
â”‚   â”‚   â”œâ”€â”€ Login.jsx
â”‚   â”‚   â””â”€â”€ Register.jsx
â”‚   â”œâ”€â”€ Customer/
â”‚   â”‚   â”œâ”€â”€ CustomerDashboard.css
â”‚   â”‚   â””â”€â”€ CustomerDashboard.jsx
â”‚   â”œâ”€â”€ Doctor/
â”‚   â”‚   â”œâ”€â”€ DoctorDashboard.css
â”‚   â”‚   â””â”€â”€ DoctorDashboard.jsx
â”‚   â”œâ”€â”€ Manager/
â”‚   â”‚   â”œâ”€â”€ DoctorDetail.css
â”‚   â”‚   â”œâ”€â”€ DoctorDetail.jsx
â”‚   â”‚   â”œâ”€â”€ ManagerDashboard.css
â”‚   â”‚   â”œâ”€â”€ ManagerDashboard.jsx
â”‚   â”‚   â”œâ”€â”€ PatientDetail.css
â”‚   â”‚   â””â”€â”€ PatientDetail.jsx
â”‚   â”œâ”€â”€ Settings/
â”‚   â”‚   â”œâ”€â”€ Settings.css
â”‚   â”‚   â””â”€â”€ Settings.jsx
â”‚   â””â”€â”€ Website/
â”‚       â”œâ”€â”€ Home.css
â”‚       â””â”€â”€ Home.jsx
â”œâ”€â”€ routes/
â”‚   â””â”€â”€ AppRouter.jsx
â”œâ”€â”€ services/
â”‚   â”œâ”€â”€ apiClient.js
â”‚   â”œâ”€â”€ authService.js
â”‚   â””â”€â”€ notificationService.js
â”œâ”€â”€ utils/
â”‚   â”œâ”€â”€ dateUtils.js
â”‚   â”œâ”€â”€ imageUtils.js
â”‚   â”œâ”€â”€ renderUtils.js
â”‚   â””â”€â”€ SafeComponents.jsx
â””â”€â”€ test/ (excluded from documentation)

---

## File: App.css
```css
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
  background: #fff;
  color: #1f2937;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}
```

## File: App.jsx
```jsx
import React from 'react';
import { BrowserRouter } from 'react-router-dom';
import { AuthProvider } from './contexts/AuthContext';
import AppRouter from './routes/AppRouter';
import ErrorBoundary from './components/ErrorBoundary';
import StagewiseToolbarDevOnly from './StagewiseToolbarDevOnly';
import './App.css';

/**
 * Main App component that sets up the application structure
 * with routing, authentication context, and error boundaries
 */
function App() {
  return (
    <ErrorBoundary>
      <BrowserRouter>
        <AuthProvider>
          <div className="App">
            <StagewiseToolbarDevOnly />
            <AppRouter />
          </div>
        </AuthProvider>
      </BrowserRouter>
    </ErrorBoundary>
  );
}

export default App;
```

## File: index.css
```css
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

*::before,
*::after {
  box-sizing: border-box;
}

:root {
  /* Medical Green Color Palette */
  --primary-color: #22c55e;
  --primary-dark: #16a34a;
  --primary-light: #86efac;
  --primary-bg: #f0fdf4;
  
  /* Secondary Colors */
  --secondary-color: #0ea5e9;
  --secondary-dark: #0284c7;
  --secondary-light: #7dd3fc;
  
  /* Neutral Colors */
  --white: #ffffff;
  --gray-50: #f9fafb;
  --gray-100: #f3f4f6;
  --gray-200: #e5e7eb;
  --gray-300: #d1d5db;
  --gray-400: #9ca3af;
  --gray-500: #6b7280;
  --gray-600: #4b5563;
  --gray-700: #374151;
  --gray-800: #1f2937;
  --gray-900: #111827;
  
  /* Status Colors */
  --success-color: #10b981;
  --warning-color: #f59e0b;
  --error-color: #ef4444;
  --info-color: #3b82f6;
  
  /* Background Colors */
  --bg-primary: var(--white);
  --bg-secondary: var(--gray-50);
  --bg-tertiary: var(--gray-100);
  
  /* Text Colors */
  --text-primary: var(--gray-900);
  --text-secondary: var(--gray-700);
  --text-muted: var(--gray-500);
  
  /* Border Colors */
  --border-color: var(--gray-200);
  --border-hover: var(--gray-300);
  
  /* Shadows */
  --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
  --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
  --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
  
  /* Transitions */
  --transition-fast: 150ms ease;
  --transition-normal: 300ms ease;
  --transition-slow: 500ms ease;
  
  /* Spacing */
  --space-xs: 0.25rem;
  --space-sm: 0.5rem;
  --space-md: 1rem;
  --space-lg: 1.5rem;
  --space-xl: 2rem;
  --space-2xl: 3rem;
  
  /* Border Radius */
  --radius-sm: 0.25rem;
  --radius-md: 0.375rem;
  --radius-lg: 0.5rem;
  --radius-xl: 0.75rem;
  --radius-2xl: 1rem;
  
  /* Typography */
  --font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
  --font-size-xs: 0.75rem;
  --font-size-sm: 0.875rem;
  --font-size-base: 1rem;
  --font-size-lg: 1.125rem;
  --font-size-xl: 1.25rem;
  --font-size-2xl: 1.5rem;
  --font-size-3xl: 1.875rem;
  --font-size-4xl: 2.25rem;
}

html {
  font-size: 16px;
  line-height: 1.5;
  -webkit-text-size-adjust: 100%;
}

body, html {
  min-height: 100vh;
  margin: 0;
  padding: 0;
}

body {
  font-family: var(--font-family);
  font-size: var(--font-size-base);
  line-height: 1.6;
  color: var(--text-primary);
  background-color: var(--bg-secondary);
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

#root {
  min-height: 100vh;
  display: flex;
  flex-direction: column;
}

/* Typography */
h1, h2, h3, h4, h5, h6 {
  font-weight: 600;
  line-height: 1.2;
  color: var(--text-primary);
  margin-bottom: var(--space-md);
}

h1 { font-size: var(--font-size-4xl); }
h2 { font-size: var(--font-size-3xl); }
h3 { font-size: var(--font-size-2xl); }
h4 { font-size: var(--font-size-xl); }
h5 { font-size: var(--font-size-lg); }
h6 { font-size: var(--font-size-base); }

p {
  margin-bottom: var(--space-md);
  color: var(--text-secondary);
}

/* Links */
a {
  color: var(--primary-color);
  text-decoration: none;
  transition: color var(--transition-fast);
}

a:hover {
  color: var(--primary-dark);
  text-decoration: underline;
}

a:focus-visible {
  outline: 2px solid var(--primary-color);
  outline-offset: 2px;
  border-radius: var(--radius-sm);
}

/* Form Elements */
input, textarea, select, button {
  font-family: inherit;
  font-size: inherit;
}

input, textarea, select {
  width: 100%;
  padding: var(--space-sm) var(--space-md);
  border: 1px solid var(--border-color);
  border-radius: var(--radius-md);
  background-color: var(--bg-primary);
  color: var(--text-primary);
  transition: border-color var(--transition-fast), box-shadow var(--transition-fast);
}

input:focus, textarea:focus, select:focus {
  outline: none;
  border-color: var(--primary-color);
  box-shadow: 0 0 0 3px rgba(34, 197, 94, 0.1);
}

button {
  cursor: pointer;
  border: none;
  border-radius: var(--radius-md);
  padding: var(--space-sm) var(--space-lg);
  font-weight: 500;
  transition: all var(--transition-fast);
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: var(--space-sm);
}

button:focus-visible {
  outline: 2px solid var(--primary-color);
  outline-offset: 2px;
}

button:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}

/* Button Variants */
.btn-primary {
  background-color: var(--primary-color);
  color: var(--white);
}

.btn-primary:hover:not(:disabled) {
  background-color: var(--primary-dark);
  transform: translateY(-1px);
  box-shadow: var(--shadow-md);
}

.btn-secondary {
  background-color: var(--gray-200);
  color: var(--text-primary);
}

.btn-secondary:hover:not(:disabled) {
  background-color: var(--gray-300);
}

.btn-outline {
  background-color: transparent;
  color: var(--primary-color);
  border: 1px solid var(--primary-color);
}

.btn-outline:hover:not(:disabled) {
  background-color: var(--primary-color);
  color: var(--white);
}

/* Utility Classes */
.text-center { text-align: center; }
.text-left { text-align: left; }
.text-right { text-align: right; }

.font-bold { font-weight: 700; }
.font-semibold { font-weight: 600; }
.font-medium { font-weight: 500; }

.text-primary { color: var(--text-primary); }
.text-secondary { color: var(--text-secondary); }
.text-muted { color: var(--text-muted); }
.text-success { color: var(--success-color); }
.text-warning { color: var(--warning-color); }
.text-error { color: var(--error-color); }

.bg-primary { background-color: var(--bg-primary); }
.bg-secondary { background-color: var(--bg-secondary); }
.bg-success { background-color: var(--success-color); }
.bg-warning { background-color: var(--warning-color); }
.bg-error { background-color: var(--error-color); }

.border { border: 1px solid var(--border-color); }
.border-radius { border-radius: var(--radius-md); }

.shadow-sm { box-shadow: var(--shadow-sm); }
.shadow-md { box-shadow: var(--shadow-md); }
.shadow-lg { box-shadow: var(--shadow-lg); }

/* Layout */
.container {
  max-width: 1200px;
  margin: 0 auto;
  padding: 0 var(--space-lg);
}

.flex { display: flex; }
.flex-col { flex-direction: column; }
.items-center { align-items: center; }
.justify-center { justify-content: center; }
.justify-between { justify-content: space-between; }

.grid {
  display: grid;
  gap: var(--space-lg);
}

.gap-xs { gap: var(--space-xs); }
.gap-sm { gap: var(--space-sm); }
.gap-md { gap: var(--space-md); }
.gap-lg { gap: var(--space-lg); }
.gap-xl { gap: var(--space-xl); }

/* Spacing */
.m-xs { margin: var(--space-xs); }
.m-sm { margin: var(--space-sm); }
.m-md { margin: var(--space-md); }
.m-lg { margin: var(--space-lg); }
.m-xl { margin: var(--space-xl); }

.p-xs { padding: var(--space-xs); }
.p-sm { padding: var(--space-sm); }
.p-md { padding: var(--space-md); }
.p-lg { padding: var(--space-lg); }
.p-xl { padding: var(--space-xl); }

/* Responsive Design */
@media (max-width: 768px) {
  :root {
    --font-size-4xl: 1.875rem;
    --font-size-3xl: 1.5rem;
    --font-size-2xl: 1.25rem;
  }
  
  .container {
    padding: 0 var(--space-md);
  }
}

/* Loading States */
.loading {
  opacity: 0.7;
  pointer-events: none;
}

.spinner {
  width: 20px;
  height: 20px;
  border: 2px solid var(--gray-300);
  border-top: 2px solid var(--primary-color);
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

/* Error States */
.error-message {
  color: var(--error-color);
  background-color: rgba(239, 68, 68, 0.1);
  border: 1px solid rgba(239, 68, 68, 0.2);
  border-radius: var(--radius-md);
  padding: var(--space-md);
  margin-bottom: var(--space-md);
}

.success-message {
  color: var(--success-color);
  background-color: rgba(16, 185, 129, 0.1);
  border: 1px solid rgba(16, 185, 129, 0.2);
  border-radius: var(--radius-md);
  padding: var(--space-md);
  margin-bottom: var(--space-md);
}

/* Accessibility */
.sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border: 0;
}

/* Focus management */
*:focus {
  outline: none;
}

*:focus-visible {
  outline: 2px solid var(--primary-color);
  outline-offset: 2px;
}

/* Print styles */
@media print {
  * {
    background: transparent !important;
    color: black !important;
    box-shadow: none !important;
    text-shadow: none !important;
  }
  
  a, a:visited {
    text-decoration: underline;
  }
  
  abbr[title]:after {
    content: " (" attr(title) ")";
  }
  
  pre, blockquote {
    border: 1px solid #999;
    page-break-inside: avoid;
  }
  
  thead {
    display: table-header-group;
  }
  
  tr, img {
    page-break-inside: avoid;
  }
  
  img {
    max-width: 100% !important;
  }
  
  p, h2, h3 {
    orphans: 3;
    widows: 3;
  }
  
  h2, h3 {
    page-break-after: avoid;
  }
}
```

## File: index.jsx
```jsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import { BrowserRouter } from 'react-router-dom';
import App from './App';
import './index.css';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <BrowserRouter>
      <App />
    </BrowserRouter>
  </React.StrictMode>
);
```

## File: main.jsx
```jsx
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App.jsx';
import './index.css';

/**
 * Main application entry point
 * Renders the App component into the root DOM element
 */
ReactDOM.createRoot(document.getElementById('root')).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
);
```

## File: StagewiseToolbarDevOnly.jsx
```jsx
import React from 'react';

// Safe lazy loading with error handling for optional dev dependencies
const createSafeLazyComponent = (packageName, fallbackComponent = null) => {
  return React.lazy(async () => {
    try {
      const module = await import(packageName);
      return module;
    } catch (error) {
      console.warn(`Dev dependency ${packageName} not available:`, error.message);
      // Return a fallback component that renders nothing
      return {
        default: fallbackComponent || (() => null)
      };
    }
  });
};

// Create safe lazy components for dev toolbar
const StagewiseToolbar = createSafeLazyComponent('@stagewise/toolbar-react');
const StagewisePlugins = createSafeLazyComponent('@stagewise-plugins/react');

export default function StagewiseToolbarDevOnly() {
  if (!import.meta.env.DEV) {
    return null;
  }
  
  return (
    <React.Suspense fallback={<div style={{
      position: 'fixed',
      top: 0,
      left: 0,
      right: 0,
      background: '#f0f0f0',
      padding: '8px',
      textAlign: 'center',
      fontSize: '12px',
      color: '#666',
      zIndex: 9999
    }}>Loading Dev Toolbar...</div>}>
      <StagewiseToolbar>
        <StagewisePlugins />
      </StagewiseToolbar>
    </React.Suspense>
  );
}
```

---

## File: contexts/AuthContext.jsx
```jsx
import React, { createContext, useContext, useState, useEffect } from 'react';
import authService from '../services/authService';
import notificationService from '../services/notificationService';
import useSessionMonitor from './useSessionMonitor';

/**
 * Authentication Context for managing user authentication state
 * Provides login, logout, and user state management across the application
 */
const AuthContext = createContext(null);

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};

export const AuthProvider = ({ children }) => {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState('');

  // Session monitoring
  const {
    sessionStatus,
    showTimeoutModal,
    extendSession,
    handleAutoLogout
  } = useSessionMonitor(!!user, logout);

  // Check for existing authentication on app start
  useEffect(() => {
    const initializeAuth = async () => {
      try {
        const token = localStorage.getItem('token');
        if (token) {
          const userData = await authService.getCurrentUser();
          if (userData) {
            setUser(userData);
            // Initialize notifications after successful auth
            await notificationService.getInitialNotifications();
          } else {
            localStorage.removeItem('token');
          }
        }
      } catch (error) {
        console.error('Auth initialization error:', error);
        localStorage.removeItem('token');
      } finally {
        setLoading(false);
      }
    };

    initializeAuth();
  }, []);

  const login = async (credentials) => {
    try {
      setLoading(true);
      setError('');
      
      const response = await authService.login(credentials);
      
      if (response.success && response.user) {
        setUser(response.user);
        localStorage.setItem('token', response.token);
        
        // Initialize notifications after successful login
        await notificationService.getInitialNotifications();
        
        return { success: true, user: response.user };
      } else {
        const errorMsg = response.error || 'Login failed';
        setError(errorMsg);
        return { success: false, error: errorMsg };
      }
    } catch (error) {
      const errorMsg = error.message || 'Login failed';
      setError(errorMsg);
      return { success: false, error: errorMsg };
    } finally {
      setLoading(false);
    }
  };

  const register = async (userData) => {
    try {
      setLoading(true);
      setError('');
      
      const response = await authService.register(userData);
      
      if (response.success) {
        return { success: true, message: response.message };
      } else {
        const errorMsg = response.error || 'Registration failed';
        setError(errorMsg);
        return { success: false, error: errorMsg };
      }
    } catch (error) {
      const errorMsg = error.message || 'Registration failed';
      setError(errorMsg);
      return { success: false, error: errorMsg };
    } finally {
      setLoading(false);
    }
  };

  async function logout() {
    try {
      setLoading(true);
      
      // Call logout service to invalidate session
      await authService.logout();
      
      // Reset notification polling state
      notificationService.resetPollingState();
      
      // Clear local state
      setUser(null);
      setError('');
      localStorage.removeItem('token');
      
    } catch (error) {
      console.error('Logout error:', error);
      // Still clear local state even if server call fails
      setUser(null);
      setError('');
      localStorage.removeItem('token');
      notificationService.resetPollingState();
    } finally {
      setLoading(false);
    }
  }

  const updateUser = async (userData) => {
    try {
      setLoading(true);
      setError('');
      
      const response = await authService.updateProfile(userData);
      
      if (response.success && response.user) {
        setUser(response.user);
        return { success: true, user: response.user };
      } else {
        const errorMsg = response.error || 'Profile update failed';
        setError(errorMsg);
        return { success: false, error: errorMsg };
      }
    } catch (error) {
      const errorMsg = error.message || 'Profile update failed';
      setError(errorMsg);
      return { success: false, error: errorMsg };
    } finally {
      setLoading(false);
    }
  };

  const value = {
    user,
    loading,
    error,
    login,
    register,
    logout,
    updateUser,
    setError,
    // Session monitoring
    sessionStatus,
    showTimeoutModal,
    extendSession,
    handleAutoLogout
  };

  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  );
};

export default AuthContext;
```

## File: contexts/useAuth.js
```js
import { useContext } from 'react';
import AuthContext from './AuthContext';

/**
 * Custom hook to access authentication context
 * @returns {Object} Authentication context value
 */
export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};

export default useAuth;
```

## File: contexts/useSessionMonitor.js
```js
import { useState, useEffect, useCallback, useRef } from 'react';
import authService from '../services/authService';

/**
 * Custom hook for client-side session timeout management
 * 
 * Features:
 * - Client-side session timeout calculation (30 minutes)
 * - Mouse movement detection for user activity
 * - Countdown timer starting when user becomes idle
 * - Session invalidation request only when timeout occurs
 * - Early warning 1 minute before timeout
 * - Eliminates frequent server session checks
 */
const useSessionMonitor = (isAuthenticated, onLogout) => {
  const [sessionStatus, setSessionStatus] = useState({
    isActive: false,
    remainingSeconds: 0,
    expiresAt: null
  });
  
  const [showTimeoutModal, setShowTimeoutModal] = useState(false);
  const [lastActivity, setLastActivity] = useState(Date.now());
  
  const sessionTimer = useRef(null);
  const countdownTimer = useRef(null);
  const timeoutModalShown = useRef(false);
  const sessionStartTime = useRef(Date.now());
  
  // Session timeout duration (30 minutes)
  const SESSION_TIMEOUT_DURATION = 30 * 60 * 1000; // 30 minutes in milliseconds
  
  // Warning threshold (1 minute = 60 seconds)
  const WARNING_THRESHOLD_SECONDS = 60;
  
  // Countdown update interval (1 second)
  const COUNTDOWN_UPDATE_INTERVAL = 1000;

  /**
   * Calculate remaining session time based on last activity
   */
  const calculateRemainingTime = useCallback(() => {
    const now = Date.now();
    const timeSinceActivity = now - lastActivity;
    const remaining = SESSION_TIMEOUT_DURATION - timeSinceActivity;
    return Math.max(0, Math.floor(remaining / 1000)); // Return seconds
  }, [lastActivity, SESSION_TIMEOUT_DURATION]);

  /**
   * Handle automatic logout with session invalidation
   */
  const handleAutoLogout = useCallback(async () => {
    setShowTimeoutModal(false);
    timeoutModalShown.current = false;
    
    // Clear timers
    if (sessionTimer.current) {
      clearTimeout(sessionTimer.current);
      sessionTimer.current = null;
    }
    
    if (countdownTimer.current) {
      clearInterval(countdownTimer.current);
      countdownTimer.current = null;
    }
    
    try {
      // Send session invalidation request to server
      await authService.logout();
    } catch (error) {
      console.error('Session invalidation failed:', error);
    }
    
    // Call the logout function
    if (onLogout) {
      onLogout();
    }
  }, [onLogout]);

  /**
   * Update session status and handle timeout logic
   */
  const updateSessionStatus = useCallback(() => {
    if (!isAuthenticated) return;
    
    const remainingSeconds = calculateRemainingTime();
    const expiresAt = new Date(lastActivity + SESSION_TIMEOUT_DURATION);
    
    setSessionStatus({
      isActive: remainingSeconds > 0,
      remainingSeconds,
      expiresAt
    });
    
    // Show warning modal if session is about to expire
    if (remainingSeconds <= WARNING_THRESHOLD_SECONDS && remainingSeconds > 0) {
      if (!timeoutModalShown.current) {
        setShowTimeoutModal(true);
        timeoutModalShown.current = true;
      }
    } else if (remainingSeconds > WARNING_THRESHOLD_SECONDS) {
      // Reset modal flag if we're outside warning threshold
      timeoutModalShown.current = false;
      setShowTimeoutModal(false);
    }
    
    // Auto-logout if session has expired
    if (remainingSeconds <= 0) {
      handleAutoLogout();
    }
  }, [isAuthenticated, calculateRemainingTime, lastActivity, SESSION_TIMEOUT_DURATION, handleAutoLogout]);

  /**
   * Extend current session by resetting activity timestamp
   */
  const extendSession = useCallback(async () => {
    try {
      // Reset activity timestamp to current time
      const now = Date.now();
      setLastActivity(now);
      sessionStartTime.current = now;
      
      // Hide timeout modal
      setShowTimeoutModal(false);
      timeoutModalShown.current = false;
      
      // Optionally notify server of session extension
      await authService.extendSession();
      
      // Update session status immediately
      updateSessionStatus();
      
      return true;
    } catch (error) {
      console.error('Session extension failed:', error);
      handleAutoLogout();
      return false;
    }
  }, [updateSessionStatus, handleAutoLogout]);

  /**
   * Update last activity timestamp on user activity
   */
  const updateActivity = useCallback(() => {
    const now = Date.now();
    setLastActivity(now);
    
    // Reset modal flag when user becomes active again
    if (timeoutModalShown.current) {
      timeoutModalShown.current = false;
      setShowTimeoutModal(false);
    }
  }, []);

  /**
   * Start session monitoring timers
   */
  const startMonitoring = useCallback(() => {
    if (!isAuthenticated) return;
    
    // Clear existing timers
    if (sessionTimer.current) {
      clearTimeout(sessionTimer.current);
    }
    if (countdownTimer.current) {
      clearInterval(countdownTimer.current);
    }
    
    // Initialize session start time
    const now = Date.now();
    sessionStartTime.current = now;
    setLastActivity(now);
    
    // Start countdown timer that updates every second
    countdownTimer.current = setInterval(() => {
      updateSessionStatus();
    }, COUNTDOWN_UPDATE_INTERVAL);
    
    // Set session timeout timer
    sessionTimer.current = setTimeout(() => {
      handleAutoLogout();
    }, SESSION_TIMEOUT_DURATION);
    
    // Initial status update
    updateSessionStatus();
  }, [isAuthenticated, updateSessionStatus, handleAutoLogout, SESSION_TIMEOUT_DURATION]);

  /**
   * Stop session monitoring
   */
  const stopMonitoring = useCallback(() => {
    if (sessionTimer.current) {
      clearTimeout(sessionTimer.current);
      sessionTimer.current = null;
    }
    
    if (countdownTimer.current) {
      clearInterval(countdownTimer.current);
      countdownTimer.current = null;
    }
    
    setShowTimeoutModal(false);
    timeoutModalShown.current = false;
    
    setSessionStatus({
      isActive: false,
      remainingSeconds: 0,
      expiresAt: null
    });
  }, []);

  /**
   * Reset session timeout when user activity is detected
   */
  const resetSessionTimeout = useCallback(() => {
    if (!isAuthenticated) return;
    
    // Clear existing session timeout
    if (sessionTimer.current) {
      clearTimeout(sessionTimer.current);
    }
    
    // Set new session timeout
    sessionTimer.current = setTimeout(() => {
      handleAutoLogout();
    }, SESSION_TIMEOUT_DURATION);
    
    updateActivity();
  }, [isAuthenticated, handleAutoLogout, updateActivity, SESSION_TIMEOUT_DURATION]);

  /**
   * Setup mouse movement detection for user activity
   */
  useEffect(() => {
    if (!isAuthenticated) return;
    
    let mouseMoveTimer = null;
    
    const handleMouseMove = () => {
      // Throttle mouse movement events to prevent excessive updates
      if (mouseMoveTimer) {
        clearTimeout(mouseMoveTimer);
      }
      
      mouseMoveTimer = setTimeout(() => {
        resetSessionTimeout();
      }, 100); // 100ms throttle
    };
    
    const handleUserActivity = () => {
      resetSessionTimeout();
    };
    
    // Activity events to monitor
    const activityEvents = ['mousedown', 'keypress', 'scroll', 'touchstart', 'click'];
    
    // Add mouse movement listener
    document.addEventListener('mousemove', handleMouseMove, { passive: true });
    
    // Add other activity listeners
    activityEvents.forEach(event => {
      document.addEventListener(event, handleUserActivity, { passive: true });
    });
    
    // Cleanup
    return () => {
      if (mouseMoveTimer) {
        clearTimeout(mouseMoveTimer);
      }
      document.removeEventListener('mousemove', handleMouseMove);
      activityEvents.forEach(event => {
        document.removeEventListener(event, handleUserActivity);
      });
    };
  }, [isAuthenticated, resetSessionTimeout]);

  /**
   * Main effect - start/stop monitoring based on authentication
   */
  useEffect(() => {
    if (isAuthenticated) {
      startMonitoring();
    } else {
      stopMonitoring();
    }
    
    return () => {
      stopMonitoring();
    };
  }, [isAuthenticated, startMonitoring, stopMonitoring]);

  /**
   * Cleanup on unmount
   */
  useEffect(() => {
    return () => {
      stopMonitoring();
    };
  }, [stopMonitoring]);

  return {
    sessionStatus,
    showTimeoutModal,
    extendSession,
    handleAutoLogout,
    updateActivity
  };
};

export default useSessionMonitor;
```

---

## File: components/manager/ExportData.jsx
```jsx
import React from 'react';
import { Button } from '@mui/material';
import DownloadIcon from '@mui/icons-material/Download';
import apiClient from '../../services/apiClient';

const ExportData = () => {
    const handleExport = async (endpoint, filename) => {
        try {
            const response = await apiClient.get(`/export/${endpoint}`, {
                responseType: 'blob'
            });
            
            // Create a URL for the blob
            const url = window.URL.createObjectURL(new Blob([response.data]));
            
            // Create a temporary link element
            const link = document.createElement('a');
            link.href = url;
            link.setAttribute('download', filename);
            
            // Append to body, click, and remove
            document.body.appendChild(link);
            link.click();
            link.parentNode.removeChild(link);
            
            // Clean up the URL
            window.URL.revokeObjectURL(url);
        } catch (error) {
            console.error(`Error downloading ${filename}:`, error);
            alert(`Failed to download ${filename}. Please try again later.`);
        }
    };

    return (
        <div style={{ display: 'flex', gap: '16px', flexWrap: 'wrap', margin: '16px 0' }}>
            <Button
                variant="contained"
                color="primary"
                startIcon={<DownloadIcon />}
                onClick={() => handleExport('patient-profiles', 'patient_profiles.csv')}
            >
                Export Patient Profiles
            </Button>
            
            <Button
                variant="contained"
                color="primary"
                startIcon={<DownloadIcon />}
                onClick={() => handleExport('doctor-slots', 'doctor_slots.csv')}
            >
                Export Doctor Slots
            </Button>
            
            <Button
                variant="contained"
                color="primary"
                startIcon={<DownloadIcon />}
                onClick={() => handleExport('arv-treatments', 'arv_treatments.csv')}
            >
                Export ARV Treatments
            </Button>
            
            <Button
                variant="contained"
                color="primary"
                startIcon={<DownloadIcon />}
                onClick={() => handleExport('appointments', 'appointments.csv')}
            >
                Export Appointments
            </Button>
        </div>
    );
};

export default ExportData;
```

## File: components/notifications/NotificationIcon.jsx
```jsx
import React from 'react';
import './NotificationIcon.css';

const NotificationIcon = ({ count, onClick }) => {
    return (
        <div className="notification-icon" onClick={onClick}>
            <svg viewBox="0 0 24 24" fill="currentColor" width="24" height="24">
                <path d="M12 22c1.1 0 2-.9 2-2h-4c0 1.1.9 2 2 2zm6-6v-5c0-3.07-1.63-5.64-4.5-6.32V4c0-.83-.67-1.5-1.5-1.5s-1.5.67-1.5 1.5v.68C7.63 5.36 6 7.92 6 11v5l-2 2v1h16v-1l-2-2z" />
            </svg>
            {count > 0 && <span className="badge">{count}</span>}
        </div>
    );
};

export default NotificationIcon;
```

## File: components/notifications/NotificationPanel.jsx
```jsx
import React, { useState } from 'react';
import PropTypes from 'prop-types';
import NotificationItem from './NotificationItem';
import './NotificationPanel.css';

/**
 * Enhanced notification panel component with filtering and priority indicators
 * Supports different notification types and improved user interactions
 */
const NotificationPanel = ({
  notifications,
  onMarkAsRead,
  onClose
}) => {
  const [filter, setFilter] = useState('all');
  const [sortBy, setSortBy] = useState('newest');

  /**
   * Filter notifications based on current filter
   */
  const getFilteredNotifications = () => {
    let filtered = notifications;

    switch (filter) {
      case 'unread':
        filtered = notifications.filter(n => !n.isRead);
        break;
      case 'high-priority':
        filtered = notifications.filter(n =>
          n.priority === 'HIGH' || n.priority === 'URGENT'
        );
        break;
      case 'today': {
        const today = new Date().toDateString();
        filtered = notifications.filter(n =>
          new Date(n.createdAt).toDateString() === today
        );
        break;
      }
      default:
        filtered = notifications;
    }

    // Sort notifications
    return filtered.sort((a, b) => {
      switch (sortBy) {
        case 'oldest':
          return new Date(a.createdAt) - new Date(b.createdAt);
        case 'priority': {
          const priorityOrder = { 'URGENT': 4, 'HIGH': 3, 'MEDIUM': 2, 'LOW': 1 };
          return (priorityOrder[b.priority] || 2) - (priorityOrder[a.priority] || 2);
        }
        case 'newest':
        default:
          return new Date(b.createdAt) - new Date(a.createdAt);
      }
    });
  };

  const filteredNotifications = getFilteredNotifications();
  const unreadCount = notifications.filter(n => !n.isRead).length;
  const highPriorityCount = notifications.filter(n =>
    (n.priority === 'HIGH' || n.priority === 'URGENT') && !n.isRead
  ).length;

  return (
    <div className="notification-panel">
      <div className="panel-header">
        <div className="header-content">
          <h3>Notifications</h3>
          <div className="notification-stats">
            {unreadCount > 0 && (
              <span className="unread-badge">{unreadCount} unread</span>
            )}
            {highPriorityCount > 0 && (
              <span className="priority-badge">{highPriorityCount} urgent</span>
            )}
          </div>
        </div>
        
        <div className="panel-actions">
          {onClose && (
            <button
              className="close-panel-btn"
              onClick={onClose}
              title="Close panel"
              aria-label="Close notification panel"
            >
              Ã—
            </button>
          )}
        </div>
      </div>

      {/* Filter and Sort Controls */}
      <div className="panel-controls">
        <div className="filter-controls">
          <select
            value={filter}
            onChange={(e) => setFilter(e.target.value)}
            className="filter-select"
            aria-label="Filter notifications"
          >
            <option value="all">All ({notifications.length})</option>
            <option value="unread">Unread ({unreadCount})</option>
            <option value="high-priority">High Priority ({highPriorityCount})</option>
            <option value="today">Today</option>
          </select>
          
          <select
            value={sortBy}
            onChange={(e) => setSortBy(e.target.value)}
            className="sort-select"
            aria-label="Sort notifications"
          >
            <option value="newest">Newest First</option>
            <option value="oldest">Oldest First</option>
            <option value="priority">By Priority</option>
          </select>
        </div>
      </div>

      {/* Notifications List */}
      <div className="panel-body">
        {filteredNotifications.length > 0 ? (
          <div className="notifications-list">
            {filteredNotifications.map(notification => (
              <NotificationItem
                key={notification.notificationId}
                notification={notification}
                onMarkAsRead={onMarkAsRead}
                enhanced={true}
              />
            ))}
          </div>
        ) : (
          <div className="empty-state">
            <div className="empty-icon">
              {filter === 'unread' ? 'âœ…' : 'ğŸ“¨'}
            </div>
            <p className="empty-message">
              {filter === 'unread'
                ? 'All caught up! No unread notifications.'
                : filter === 'high-priority'
                ? 'No high priority notifications.'
                : filter === 'today'
                ? 'No notifications today.'
                : 'No notifications found.'
              }
            </p>
          </div>
        )}
      </div>

      {/* Footer with quick actions */}
      {notifications.length > 0 && (
        <div className="panel-footer">
          <div className="footer-stats">
            <span className="stats-text">
              Showing {filteredNotifications.length} of {notifications.length}
            </span>
          </div>
        </div>
      )}
    </div>
  );
};

NotificationPanel.propTypes = {
  notifications: PropTypes.arrayOf(PropTypes.shape({
    notificationId: PropTypes.number.isRequired,
    title: PropTypes.string.isRequired,
    message: PropTypes.string.isRequired,
    isRead: PropTypes.bool.isRequired,
    createdAt: PropTypes.string.isRequired,
    priority: PropTypes.string,
    type: PropTypes.string
  })).isRequired,
  onMarkAsRead: PropTypes.func.isRequired,
  onClose: PropTypes.func
};

export default NotificationPanel;
```

## File: components/ui/SessionTimeoutModal.jsx
```jsx
import React, { useState, useEffect } from 'react';
import './SessionTimeoutModal.css';

/**
 * Modal component that appears when user session is about to expire
 * Provides options to extend the session or logout
 * Works with client-side session management system
 */
const SessionTimeoutModal = ({
  isOpen,
  remainingSeconds,
  onExtendSession,
  onLogout
}) => {
  const [countdown, setCountdown] = useState(remainingSeconds || 0);

  useEffect(() => {
    if (isOpen && remainingSeconds > 0) {
      setCountdown(remainingSeconds);
    }
  }, [isOpen, remainingSeconds]);

  useEffect(() => {
    if (!isOpen) return;

    const timer = setInterval(() => {
      setCountdown(prevCount => {
        if (prevCount <= 1) {
          clearInterval(timer);
          onLogout(); // Auto-logout when countdown reaches 0
          return 0;
        }
        return prevCount - 1;
      });
    }, 1000);

    return () => clearInterval(timer);
  }, [isOpen, onLogout]);

  if (!isOpen) return null;

  const formatTime = (seconds) => {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  };

  return (
    <div className="session-timeout-modal-overlay">
      <div className="session-timeout-modal">
        <div className="session-timeout-modal-header">
          <h3>âš ï¸ Session Expiring</h3>
        </div>
        
        <div className="session-timeout-modal-content">
          <p>Your session is about to expire due to inactivity.</p>
          <p>You will be automatically logged out in:</p>
          
          <div className="session-countdown">
            <span className="countdown-time">{formatTime(countdown)}</span>
          </div>
          
          <p>Would you like to extend your session?</p>
        </div>
        
        <div className="session-timeout-modal-actions">
          <button 
            className="btn btn-primary"
            onClick={onExtendSession}
            disabled={countdown <= 0}
          >
            Yes, Extend Session
          </button>
          
          <button 
            className="btn btn-secondary"
            onClick={onLogout}
          >
            No, Logout Now
          </button>
        </div>
      </div>
    </div>
  );
};

export default SessionTimeoutModal;
```

---

## File: services/notificationService.js
```js
import apiClient from './apiClient';

/**
 * Notification service for handling all notification-related API calls
 * Provides methods for sending, managing, and retrieving notifications
 */
class NotificationService {
  /**
   * Get patients with appointments for the logged-in doctor
   */
  async getPatientsWithAppointments(doctorId) {
    try {
      const response = await apiClient.get(`/v1/notifications/doctor/patients-with-appointments?doctorId=${doctorId}`);
      const patients = response.data || [];
      
      // Validate patient data structure
      const validatedPatients = patients.map((patient, index) => {
        console.log(`Validating patient ${index}:`, patient);
        
        // Check required fields
        if (!patient.userId && !patient.patientId) {
          console.error(`Patient ${index} missing userId/patientId:`, patient);
        }
        if (!patient.firstName && !patient.patientName) {
          console.error(`Patient ${index} missing firstName/patientName:`, patient);
        }
        if (!patient.lastName) {
          console.error(`Patient ${index} missing lastName:`, patient);
        }
        if (!patient.email && !patient.patientEmail) {
          console.error(`Patient ${index} missing email/patientEmail:`, patient);
        }
        
        // Return standardized structure
        return {
          userId: patient.userId || patient.patientId,
          firstName: patient.firstName || patient.patientName || 'Unknown',
          lastName: patient.lastName || 'Patient',
          email: patient.email || patient.patientEmail || 'No email',
          lastAppointment: patient.lastAppointment,
          appointmentStatus: patient.appointmentStatus
        };
      });
      
      console.log(`Successfully fetched ${validatedPatients.length} patients with appointments`);
      
      return {
        success: true,
        data: validatedPatients
      };
    } catch (error) {
      console.error('Error fetching patients with appointments:', error);
      return {
        success: false,
        error: error.response?.data?.message || error.message || 'Failed to fetch patients',
        data: []
      };
    }
  }

  /**
   * Get notification templates for the logged-in doctor
   */
  async getNotificationTemplates() {
    try {
      const response = await apiClient.get('/v1/notifications/templates');
      return {
        success: true,
        data: response.data || []
      };
    } catch (error) {
      console.error('Error fetching notification templates:', error);
      return {
        success: false,
        error: error.response?.data?.message || error.message || 'Failed to fetch templates',
        data: []
      };
    }
  }

  /**
   * Send a notification to selected patients
   */
  async sendNotification(notificationData, doctorId) {
    try {
      const { patientIds, templateId, customMessage, subject, priority, sendNow, scheduledDateTime, useCustomMessage } = notificationData;
      
      if (!patientIds || patientIds.length === 0) {
        return {
          success: false,
          error: 'No patients selected'
        };
      }

      const results = [];
      let successCount = 0;
      let failureCount = 0;

      // Send individual notifications for each patient (backend expects individual calls)
      for (const patientId of patientIds) {
        try {
          // Validate patientId is a valid number
          if (!patientId || isNaN(patientId)) {
            console.error(`Invalid patientId: ${patientId}`);
            results.push({
              patientId,
              success: false,
              error: 'Invalid patient ID'
            });
            failureCount++;
            continue;
          }

          // Validate templateId is a valid number
          if (!templateId || isNaN(templateId)) {
            console.error(`Invalid templateId: ${templateId}`);
            results.push({
              patientId,
              success: false,
              error: 'Invalid template ID'
            });
            failureCount++;
            continue;
          }

          const variables = {};
          if (useCustomMessage && customMessage) {
            variables.customMessage = customMessage;
          }
          if (subject) {
            variables.subject = subject;
          }
          if (priority) {
            variables.priority = priority;
          }
          if (!sendNow && scheduledDateTime) {
            variables.scheduledDateTime = scheduledDateTime;
          }

          const response = await apiClient.post(
            `/v1/notifications/doctor/send?doctorId=${doctorId}&patientId=${patientId}&templateId=${templateId}`,
            variables
          );

          results.push({ patientId, success: true, data: response.data });
          successCount++;
        } catch (error) {
          console.error(`Error sending notification to patient ${patientId}:`, error);
          results.push({
            patientId,
            success: false,
            error: error.response?.data?.message || error.message || 'Failed to send notification'
          });
          failureCount++;
        }
      }

      const overallSuccess = successCount > 0;
      const message = successCount === patientIds.length
        ? `All ${successCount} notifications sent successfully`
        : `${successCount} notifications sent, ${failureCount} failed`;

      return {
        success: overallSuccess,
        data: results,
        message,
        successCount,
        failureCount
      };
    } catch (error) {
      console.error('Error sending notifications:', error);
      return {
        success: false,
        error: error.response?.data?.message || error.message || 'Failed to send notifications'
      };
    }
  }

  /**
   * Get notification history for the logged-in doctor
   */
  async getNotificationHistory(doctorId, patientId = null) {
    try {
      const url = patientId
        ? `/v1/notifications/doctor/history/${patientId}?doctorId=${doctorId}`
        : `/v1/notifications/doctor/history?doctorId=${doctorId}`;
      
      const response = await apiClient.get(url);
      return {
        success: true,
        data: response.data || []
      };
    } catch (error) {
      console.error('Error fetching notification history:', error);
      return {
        success: false,
        error: error.response?.data?.message || error.message || 'Failed to fetch notification history',
        data: []
      };
    }
  }

  /**
   * Unsend a notification (cancel if pending)
   */
  async unsendNotification(notificationId, doctorId) {
    try {
      const response = await apiClient.post(`/v1/notifications/doctor/${notificationId}/unsend?doctorId=${doctorId}`);
      return {
        success: true,
        data: response.data,
        message: 'Notification unsent successfully'
      };
    } catch (error) {
      console.error('Error unsending notification:', error);
      return {
        success: false,
        error: error.response?.data?.message || error.message || 'Failed to unsend notification'
      };
    }
  }

  /**
   * Perform bulk operations on notifications
   */
  async bulkOperation(operation, notificationIds) {
    try {
      const response = await apiClient.post(`/v1/notifications/bulk/${operation}`, {
        notificationIds
      });
      return {
        success: true,
        data: response.data,
        message: `Bulk ${operation} completed successfully`
      };
    } catch (error) {
      console.error(`Error performing bulk ${operation}:`, error);
      return {
        success: false,
        error: error.response?.data?.message || error.message || `Failed to perform bulk ${operation}`
      };
    }
  }

  /**
   * Create a new notification template
   */
  async createTemplate(templateData) {
    try {
      const response = await apiClient.post('/v1/notifications/templates', templateData);
      return {
        success: true,
        data: response.data,
        message: 'Template created successfully'
      };
    } catch (error) {
      console.error('Error creating template:', error);
      return {
        success: false,
        error: error.response?.data?.message || error.message || 'Failed to create template'
      };
    }
  }

  /**
   * Update an existing notification template
   */
  async updateTemplate(templateId, templateData) {
    try {
      const response = await apiClient.put(`/v1/notifications/templates/${templateId}`, templateData);
      return {
        success: true,
        data: response.data,
        message: 'Template updated successfully'
      };
    } catch (error) {
      console.error('Error updating template:', error);
      return {
        success: false,
        error: error.response?.data?.message || error.message || 'Failed to update template'
      };
    }
  }

  /**
   * Delete a notification template
   */
  async deleteTemplate(templateId) {
    try {
      const response = await apiClient.delete(`/v1/notifications/templates/${templateId}`);
      return {
        success: true,
        data: response.data,
        message: 'Template deleted successfully'
      };
    } catch (error) {
      console.error('Error deleting template:', error);
      return {
        success: false,
        error: error.response?.data?.message || error.message || 'Failed to delete template'
      };
    }
  }


  /**
   * Mark a notification as read
   */
  async markAsRead(notificationId) {
    try {
      console.log('DEBUG: notificationService.markAsRead called with notificationId=', notificationId);
      console.log('DEBUG: Making API call to /v1/notifications/' + notificationId + '/read');
      
      const response = await apiClient.post(`/v1/notifications/${notificationId}/read`);
      
      console.log('DEBUG: API response received:', response);
      console.log('DEBUG: API response data:', response.data);
      console.log('DEBUG: API response status:', response.status);
      
      return {
        success: true,
        data: response.data,
        message: 'Notification marked as read'
      };
    } catch (error) {
      console.error('DEBUG: Error marking notification as read:', error);
      console.error('DEBUG: Error response:', error.response);
      console.error('DEBUG: Error response data:', error.response?.data);
      console.error('DEBUG: Error response status:', error.response?.status);
      
      return {
        success: false,
        error: error.response?.data?.message || error.message || 'Failed to mark notification as read'
      };
    }
  }

  /**
   * Mark all notifications as read for a user
   */
  async markAllAsRead() {
    try {
      const response = await apiClient.post(`/v1/notifications/read-all`);
      return {
        success: true,
        data: response.data,
        message: 'All notifications marked as read'
      };
    } catch (error) {
      console.error('Error marking all notifications as read:', error);
      return {
        success: false,
        error: error.response?.data?.message || error.message || 'Failed to mark all notifications as read'
      };
    }
  }

  /**
   * Singleton notification polling system
   * Prevents multiple concurrent polling intervals
   */
  _pollingInterval = null;
  _subscribers = new Set();
  _lastNotificationTimestamp = null;
  _notifications = [];
  _isPolling = false;
  _lastFetchTime = 0;

  /**
   * Get notifications for the current user with timestamp tracking
   */
  async getUserNotifications() {
    try {
      const response = await apiClient.get(`/v1/notifications`);
      
      return {
        success: true,
        data: response.data || []
      };
    } catch (error) {
      return {
        success: false,
        error: error.response?.data?.message || error.message || 'Failed to fetch notifications',
        data: []
      };
    }
  }

  /**
   * Fetch initial notifications on login/authentication
   */
  async getInitialNotifications() {
    const result = await this.getUserNotifications();
    
    if (result.success) {
      this._notifications = result.data;
      this._lastNotificationTimestamp = this._getLatestTimestamp(result.data);
      this._lastFetchTime = Date.now();
      
      // Notify all subscribers of initial data
      this._subscribers.forEach(callback => {
        callback(result.data, false); // false = not new notifications
      });
    }
    
    return result;
  }

  /**
   * Poll for new notifications only (not full list)
   */
  async _pollForNewNotifications() {
    if (this._isPolling) return;
    
    this._isPolling = true;
    
    try {
      const result = await this.getUserNotifications();
      
      if (result.success) {
        const newNotifications = this._filterNewNotifications(result.data);
        
        if (newNotifications.length > 0) {
          // Only log when new notifications are found
          console.log(`New notifications found: ${newNotifications.length}`);
          
          this._notifications = result.data;
          this._lastNotificationTimestamp = this._getLatestTimestamp(result.data);
          
          // Notify subscribers of new notifications
          this._subscribers.forEach(callback => {
            callback(result.data, true); // true = new notifications found
          });
        }
        // Silent update - no console logging when no new notifications
        
        this._lastFetchTime = Date.now();
      }
    } catch (error) {
      console.error('Error polling for new notifications:', error);
    } finally {
      this._isPolling = false;
    }
  }

  /**
   * Filter notifications to find only new ones since last check
   */
  _filterNewNotifications(notifications) {
    if (!this._lastNotificationTimestamp) {
      return notifications;
    }
    
    return notifications.filter(notification => {
      const notificationTime = new Date(notification.createdAt).getTime();
      const lastTime = new Date(this._lastNotificationTimestamp).getTime();
      return notificationTime > lastTime;
    });
  }

  /**
   * Get the latest timestamp from notification list
   */
  _getLatestTimestamp(notifications) {
    if (!notifications || notifications.length === 0) {
      return null;
    }
    
    return notifications.reduce((latest, notification) => {
      const notificationTime = new Date(notification.createdAt);
      const latestTime = latest ? new Date(latest) : new Date(0);
      return notificationTime > latestTime ? notification.createdAt : latest;
    }, null);
  }

  /**
   * Start centralized notification polling
   */
  _startPolling() {
    if (this._pollingInterval) return; // Already polling
    
    this._pollingInterval = setInterval(() => {
      this._pollForNewNotifications();
    }, 30000); // Poll every 30 seconds
  }

  /**
   * Stop centralized notification polling
   */
  _stopPolling() {
    if (this._pollingInterval) {
      clearInterval(this._pollingInterval);
      this._pollingInterval = null;
    }
  }

  /**
   * Subscribe to notification updates
   * Returns a cleanup function to unsubscribe
   */
  subscribeToNotifications(onNotificationUpdate) {
    // Add subscriber to set
    this._subscribers.add(onNotificationUpdate);
    
    // Start polling if this is the first subscriber
    if (this._subscribers.size === 1) {
      this._startPolling();
    }
    
    // If we have cached notifications, provide them immediately
    if (this._notifications.length > 0) {
      onNotificationUpdate(this._notifications, false);
    }
    
    // Return cleanup function
    return () => {
      this._subscribers.delete(onNotificationUpdate);
      
      // Stop polling if no more subscribers
      if (this._subscribers.size === 0) {
        this._stopPolling();
      }
    };
  }

  /**
   * Reset notification polling state (for logout/login)
   */
  resetPollingState() {
    this._stopPolling();
    this._subscribers.clear();
    this._lastNotificationTimestamp = null;
    this._notifications = [];
    this._lastFetchTime = 0;
  }

  /**
   * Get notification analytics for dashboard
   */
  async getNotificationAnalytics() {
    try {
      const response = await apiClient.get('/v1/notifications/analytics');
      return {
        success: true,
        data: response.data || {
          totalSent: 0,
          pendingNotifications: 0,
          todaysSent: 0,
          mostUsedTemplate: null
        }
      };
    } catch (error) {
      console.error('Error fetching notification analytics:', error);
      return {
        success: false,
        error: error.response?.data?.message || error.message || 'Failed to fetch analytics',
        data: {
          totalSent: 0,
          pendingNotifications: 0,
          todaysSent: 0,
          mostUsedTemplate: null
        }
      };
    }
  }

  /**
   * Search notifications with filters
   */
  async searchNotifications(filters = {}) {
    try {
      const queryParams = new URLSearchParams();
      
      if (filters.patientId) queryParams.append('patientId', filters.patientId);
      if (filters.status) queryParams.append('status', filters.status);
      if (filters.priority) queryParams.append('priority', filters.priority);
      if (filters.startDate) queryParams.append('startDate', filters.startDate);
      if (filters.endDate) queryParams.append('endDate', filters.endDate);
      if (filters.searchTerm) queryParams.append('search', filters.searchTerm);
      
      const response = await apiClient.get(`/v1/notifications/search?${queryParams}`);
      return {
        success: true,
        data: response.data || []
      };
    } catch (error) {
      console.error('Error searching notifications:', error);
      return {
        success: false,
        error: error.response?.data?.message || error.message || 'Failed to search notifications',
        data: []
      };
    }
  }

  /**
   * Get notification delivery statistics
   */
  async getDeliveryStats(timeRange = 'week') {
    try {
      const response = await apiClient.get(`/v1/notifications/stats?range=${timeRange}`);
      return {
        success: true,
        data: response.data || {
          sent: 0,
          pending: 0,
          failed: 0,
          cancelled: 0
        }
      };
    } catch (error) {
      console.error('Error fetching delivery stats:', error);
      return {
        success: false,
        error: error.response?.data?.message || error.message || 'Failed to fetch delivery stats',
        data: {
          sent: 0,
          pending: 0,
          failed: 0,
          cancelled: 0
        }
      };
    }
  }
}

// Create and export a singleton instance
const notificationService = new NotificationService();
export default notificationService;

// Export the class as well for potential testing or multiple instances
export { NotificationService };
```

---

## File: components/Debug.jsx
```jsx
import React from 'react';

const Debug = ({ data, title = 'Debug Info', show = true }) => {
  if (!show) {
    return null
  }

  // Custom replacer to handle 'undefined' values
  const formattedData = JSON.stringify(
    data,
    (key, value) => (value === undefined ? 'undefined' : value),
    2
  )

  const styles = {
    container: {
      backgroundColor: '#f8f9fa',
      border: '1px solid #dee2e6',
      borderRadius: '4px',
      padding: '12px',
      margin: '8px 0',
      fontSize: '12px',
      fontFamily: 'monospace',
      color: '#495057'
    },
    title: {
      color: '#007bff'
    },
    data: {
      marginTop: '8px',
      wordBreak: 'break-all',
      whiteSpace: 'pre-wrap'
    }
  }

  return (
    <div style={styles.container}>
      <strong style={styles.title}>{title}:</strong>
      <div style={styles.data} data-testid="debug-data">{formattedData}</div>
    </div>
  )
}

export default Debug
```

## File: components/ErrorBoundary.css
```css
.error-boundary {
  padding: 2rem;
  margin: 1rem 0;
  background: #fee2e2;
  border: 1px solid #f87171;
  border-radius: 12px;
  text-align: center;
  color: #dc2626;
}

.error-content h3 {
  color: #dc2626;
  margin: 0 0 1rem;
  font-size: 1.2rem;
}

.error-content p {
  color: #7f1d1d;
  margin: 0 0 1.5rem;
}

.retry-button {
  background: #dc2626;
  color: #fff;
  border: none;
  padding: 0.75rem 1.5rem;
  border-radius: 8px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.3s ease;
}

.retry-button:hover {
  background: #b91c1c;
  color: #fff;
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(220, 38, 38, 0.3);
}

.error-details {
  margin-top: 1rem;
  text-align: left;
  background: #fff;
  padding: 1rem;
  border-radius: 8px;
  color: #374151;
}

.error-details summary {
  cursor: pointer;
  font-weight: 600;
  color: #dc2626;
}

.error-details pre {
  background: #f3f4f6;
  padding: 0.5rem;
  border-radius: 4px;
  overflow-x: auto;
  font-size: 0.8rem;
  color: #374151;
}
```

## File: components/ErrorBoundary.jsx
```jsx
import React from 'react';
import './ErrorBoundary.css';

class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null, errorInfo: null };
  }

  static getDerivedStateFromError() {
    // Update state so the next render will show the fallback UI
    return { hasError: true };
  }

  componentDidCatch(error, errorInfo) {
    // Log the error to console for debugging
    console.error('ErrorBoundary caught an error:', error, errorInfo);
    
    this.setState({
      error: error,
      errorInfo: errorInfo
    });
  }

  render() {
    if (this.state.hasError) {
      // Fallback UI
      return (
        <div className="error-boundary">
          <div className="error-content">
            <h3>Something went wrong</h3>
            <p>We're sorry, but something unexpected happened.</p>
            <button 
              className="retry-button"
              onClick={() => this.setState({ hasError: false, error: null, errorInfo: null })}
            >
              Try Again
            </button>
            <button
              className="retry-button"
              style={{ background: '#ff7675', marginLeft: '1rem' }}
              onClick={() => window.location.reload()}
            >
              Reload Page
            </button>
            {this.state.error && (
              <details className="error-details">
                <summary>Error Details (Development Only)</summary>
                <pre>{this.state.error.toString()}</pre>
                {this.state.errorInfo && (
                  <pre>{this.state.errorInfo.componentStack}</pre>
                )}
              </details>
            )}
          </div>
        </div>
      );
    }

    return this.props.children;
  }
}

export default ErrorBoundary;
```

## File: components/PatientRecordSection.css
```css
.patient-record-section {
  background: white;
  border-radius: 0.5rem;
  padding: 1.5rem;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
  margin-bottom: 24px;
}

.record-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 24px;
  padding-bottom: 16px;
  border-bottom: 1px solid #e5e7eb;
}

.record-header h3 {
  color: #059669;
  font-size: 1.5rem;
  font-weight: 600;
  margin: 0;
}

.error-banner, .success-banner {
  padding: 12px 16px;
  border-radius: 6px;
  margin-bottom: 16px;
  font-weight: 500;
}

.error-banner {
  background-color: #fef2f2;
  color: #dc2626;
  border: 1px solid #fecaca;
}

.success-banner {
  background-color: #f0fdf4;
  color: #059669;
  border: 1px solid #bbf7d0;
}

.record-actions, .edit-actions {
  display: flex;
  gap: 12px;
}

.btn-primary, .btn-secondary {
  padding: 10px 20px;
  border: none;
  border-radius: 6px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s ease;
  display: inline-flex;
  align-items: center;
  gap: 8px;
}

.btn-primary {
  background-color: #059669;
  color: white;
}

.btn-primary:hover:not(:disabled) {
  background-color: #047857;
}

.btn-primary:disabled {
  background-color: #9ca3af;
  cursor: not-allowed;
}

.btn-secondary {
  background-color: #6b7280;
  color: white;
}

.btn-secondary:hover {
  background-color: #4b5563;
}

.record-content {
  display: flex;
  flex-wrap: wrap;
  gap: 24px;
}

.profile-image-section {
  flex: 0 0 200px;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 16px;
  order: 1;
  margin-bottom: 2rem;
}

.profile-image-container {
  width: 150px;
  height: 150px;
  border-radius: 50%;
  overflow: hidden;
  margin: 1rem 0;
  border: 2px solid #e5e7eb;
  display: flex;
  align-items: center;
  justify-content: center;
  background-color: #f9fafb;
}

.profile-image {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.profile-image-placeholder {
  width: 150px;
  height: 150px;
  border-radius: 50%;
  background: #f3f4f6;
  display: flex;
  align-items: center;
  justify-content: center;
  color: #9ca3af;
  font-size: 0.875rem;
  margin: 1rem 0;
}

.image-upload-controls {
  margin-top: 1rem;
}

.file-input {
  display: none;
}

.upload-button {
  display: inline-block;
  padding: 0.5rem 1rem;
  background: #10b981;
  color: white;
  border-radius: 0.375rem;
  cursor: pointer;
  font-size: 0.875rem;
  transition: background-color 0.2s;
}

.upload-button:hover {
  background: #059669;
}

.record-form {
  flex: 1;
  order: 2;
}

.form-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 20px;
  margin-bottom: 24px;
}

.form-group {
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.form-group.full-width {
  grid-column: 1 / -1;
}

.form-group label {
  font-weight: 600;
  color: #374151;
  font-size: 14px;
}

.form-group input,
.form-group textarea,
.form-group select {
  padding: 10px 12px;
  border: 1px solid #d1d5db;
  border-radius: 6px;
  font-size: 14px;
  transition: border-color 0.2s ease, box-shadow 0.2s ease;
}

.form-group input:focus,
.form-group textarea:focus,
.form-group select:focus {
  outline: none;
  border-color: #059669;
  box-shadow: 0 0 0 3px rgba(5, 150, 105, 0.1);
}

.form-group textarea {
  resize: vertical;
  min-height: 80px;
}

.form-display {
  padding: 10px 12px;
  background-color: #f9fafb;
  border: 1px solid #e5e7eb;
  border-radius: 6px;
  min-height: 20px;
  color: #374151;
}

.error-message {
  background-color: #fef2f2;
  color: #dc2626;
  padding: 8px 12px;
  border-radius: 6px;
  font-size: 14px;
  margin-top: 4px;
}

.success-message {
  background-color: #f0fdf4;
  color: #059669;
  padding: 8px 12px;
  border-radius: 6px;
  font-size: 14px;
  margin-top: 4px;
}

.form-hint {
  font-size: 12px;
  color: #6b7280;
  margin-top: 4px;
}

.loading-message {
  text-align: center;
  padding: 40px;
  color: #6b7280;
}

.spinner {
  display: inline-block;
  width: 16px;
  height: 16px;
  border: 2px solid #ffffff;
  border-radius: 50%;
  border-top-color: transparent;
  animation: spin 1s ease-in-out infinite;
}

@keyframes spin {
  to { transform: rotate(360deg); }
}

.form-actions {
  display: flex;
  justify-content: flex-end;
  gap: 12px;
  padding-top: 20px;
  border-top: 1px solid #e5e7eb;
}

.privacy-alert {
  background-color: #fff3cd;
  border: 1px solid #ffeeba;
  color: #856404;
  padding: 1rem;
  margin-bottom: 1.5rem;
  border-radius: 0.5rem;
  display: flex;
  align-items: center;
  gap: 1rem;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
}

.privacy-alert i {
  font-size: 1.2rem;
  color: #856404;
}

.privacy-alert p {
  margin: 0;
  font-size: 0.95rem;
  line-height: 1.4;
}

/* Responsive Design */
@media (max-width: 900px) {
  .record-content {
    flex-direction: column;
  }
  
  .form-grid {
    grid-template-columns: 1fr;
  }
}

@media (max-width: 768px) {
  .patient-record-section {
    padding: 16px;
  }
  
  .record-header {
    flex-direction: column;
    align-items: flex-start;
    gap: 12px;
  }
  
  .profile-image-container {
    width: 120px;
    height: 120px;
  }
  
  .profile-image-section {
    flex: none;
    width: 100%;
    align-items: center;
  }
}

@media (max-width: 480px) {
  .patient-record-section {
    padding: 12px;
  }
  
  .profile-image-container {
    width: 100px;
    height: 100px;
  }
  
  .btn-primary, .btn-secondary {
    width: 100%;
    justify-content: center;
  }
}

/* Dark mode support */
@media (prefers-color-scheme: dark) {
  .patient-record-section {
    background: #1f2937;
    color: #f9fafb;
  }
  
  .record-header {
    border-bottom-color: #374151;
  }
  
  .record-header h3 {
    color: #10b981;
  }
  
  .form-group input,
  .form-group textarea,
  .form-group select {
    background-color: #374151;
    border-color: #4b5563;
    color: #f9fafb;
  }
  
  .form-display {
    background-color: #374151;
    border-color: #4b5563;
    color: #f9fafb;
  }
  
  .profile-image-container {
    background-color: #374151;
    border-color: #4b5563;
  }
}
```

## File: components/PatientRecordSection.jsx
```jsx
import React, { useState, useEffect } from 'react';
import { SafeText } from '../utils/SafeComponents';
import './PatientRecordSection.css';

const PatientRecordSection = ({
  record = {},
  onSave,
  onImageUpload,
  loading = false,
  isEditable = true,
  hideImage = false
}) => {
  // Initialize form data with empty strings
  const [formData, setFormData] = useState({
    medicalHistory: '',
    allergies: '',
    currentMedications: '', 
    notes: '',
    bloodType: '',
    emergencyContact: '',
    emergencyPhone: ''
  });

  const [error, setError] = useState('');
  const [uploading, setUploading] = useState(false);
  const [uploadError, setUploadError] = useState('');
  const [uploadSuccess, setUploadSuccess] = useState('');
  const [saveSuccess, setSaveSuccess] = useState('');

  // Debug log to track incoming data
  console.debug('PatientRecordSection received record:', record);

  // Add debug logging
  useEffect(() => {
    console.debug('PatientRecordSection mounted with record:', record);
  }, [record]);

  // Update form data when record changes
  useEffect(() => {
    console.debug('Updating form data with record:', record);
    
    // Check for error in record
    if (record?.error) {
      setError(record.error);
      return;
    }

    // Enhanced validation for record data
    const hasValidRecord = record && (
      record.success === true || 
      record.patientUserId || 
      record.patientUserID || 
      record.recordId ||
      record.patientId ||
      record.patientUsername ||
      // Check if it's a valid record object with at least some medical data
      (typeof record === 'object' && (
        record.medicalHistory !== undefined ||
        record.allergies !== undefined ||
        record.currentMedications !== undefined ||
        record.notes !== undefined ||
        record.bloodType !== undefined ||
        record.emergencyContact !== undefined ||
        record.emergencyPhone !== undefined
      ))
    );

    if (hasValidRecord) {
      setFormData({
        medicalHistory: record.medicalHistory || '',
        allergies: record.allergies || '',
        currentMedications: record.currentMedications || '',
        notes: record.notes || '',
        bloodType: record.bloodType || '',
        emergencyContact: record.emergencyContact || '',
        emergencyPhone: record.emergencyPhone || ''
      });
      setError('');
      console.debug('Form data updated successfully');
    } else {
      console.debug('No valid record data provided, using empty form');
      setFormData({
        medicalHistory: '',
        allergies: '',
        currentMedications: '',
        notes: '',
        bloodType: '',
        emergencyContact: '',
        emergencyPhone: ''
      });
    }
  }, [record]);

  // Helper to get patient name for header
  const getPatientName = () => {
    if (!record) return 'Patient';
    // Try to use patientName, then patientUsername, then fallback
    return (
      record.patientName ||
      (record.patientFirstName && record.patientLastName
        ? `${record.patientFirstName} ${record.patientLastName}`
        : null) ||
      record.patientUsername ||
      record.firstName ||
      record.username ||
      'Patient'
    );
  };

  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData(prev => ({
      ...prev,
      [name]: value
    }));
    // Clear any existing errors when user starts typing
    if (error) setError('');
    if (saveSuccess) setSaveSuccess('');
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    setError('');
    setSaveSuccess('');

    // Basic validation
    const phoneRegex = /^[+]?[1-9][\d]{0,15}$/;
    if (formData.emergencyPhone && !phoneRegex.test(formData.emergencyPhone.replace(/[\s\-()]/g, ''))) {
      setError('Please enter a valid emergency phone number');
      return;
    }

    if (formData.emergencyContact && !formData.emergencyPhone) {
      setError('Please provide an emergency phone number when adding an emergency contact');
      return;
    }

    try {
      await onSave(formData);
      setSaveSuccess('Patient record saved successfully!');
      setTimeout(() => setSaveSuccess(''), 3000);
    } catch (error) {
      console.error('Error saving patient record:', error);
      setError(error.message || 'Failed to save patient record');
    }
  };
  const handleImageUpload = async (e) => {
    if (!onImageUpload) {
      console.error('No onImageUpload function provided to PatientRecordSection');
      setUploadError('Image upload is not available');
      return;
    }

    const file = e.target.files[0];
    if (!file) {
      console.debug('No file selected');
      return;
    }

    // Clear previous states
    setUploading(true);
    setUploadError('');
    setUploadSuccess('');

    try {
      // Validate file type
      if (!file.type.startsWith('image/')) {
        throw new Error('Please select a valid image file');
      }

      // Validate file size (max 5MB)
      const maxSize = 5 * 1024 * 1024; // 5MB in bytes
      if (file.size > maxSize) {
        throw new Error('Image size must be less than 5MB');
      }

      console.debug('Processing image:', {
        type: file.type,
        size: `${(file.size / 1024 / 1024).toFixed(2)}MB`
      });

      // Create canvas for image resizing
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      const img = new Image();

      // Handle image loading
      await new Promise((resolve, reject) => {
        img.onload = () => {
          try {
            // Calculate new dimensions (max 512x512)
            const maxDimension = 512;
            let { width, height } = img;
            
            if (width > height) {
              if (width > maxDimension) {
                height = Math.round((height * maxDimension) / width);
                width = maxDimension;
              }
            } else {
              if (height > maxDimension) {
                width = Math.round((width * maxDimension) / height);
                height = maxDimension;
              }
            }

            canvas.width = width;
            canvas.height = height;

            // Draw and compress image
            ctx.drawImage(img, 0, 0, width, height);
            const base64 = canvas.toDataURL('image/jpeg', 0.8);

            console.debug('Image processed:', {
              originalSize: `${(file.size / 1024).toFixed(2)}KB`,
              newSize: `${(base64.length / 1024).toFixed(2)}KB`,
              dimensions: `${width}x${height}`
            });

            resolve(base64);
          } catch (err) {
            reject(new Error('Failed to process image: ' + err.message));
          }
        };

        img.onerror = () => reject(new Error('Failed to load image'));

        // Read file as data URL
        const reader = new FileReader();
        reader.onload = (e) => img.src = e.target.result;
        reader.onerror = () => reject(new Error('Failed to read file'));
        reader.readAsDataURL(file); 
      })
      .then(async (base64) => {
        try {
          // Call the parent's onImageUpload function
          await onImageUpload(base64);
          setUploadSuccess('Image uploaded successfully!');
          setTimeout(() => setUploadSuccess(''), 3000);
        } catch (uploadError) {
          console.error('Failed to upload image:', uploadError);
          throw uploadError;
        }
      });

    } catch (error) {
      console.error('Image upload error:', error);
      setUploadError(error.message || 'Failed to upload image');
    } finally {
      setUploading(false);
    }
  };

  // Enhanced validation for displaying record
  const hasValidRecord = record && (
    record.success === true || 
    record.patientUserId || 
    record.patientUserID || 
    record.recordId ||
    record.patientId ||
    record.patientUsername ||
    // Check if it's a valid record object with medical data
    (typeof record === 'object' && (
      record.medicalHistory !== undefined ||
      record.allergies !== undefined ||
      record.currentMedications !== undefined ||
      record.notes !== undefined ||
      record.bloodType !== undefined ||
      record.emergencyContact !== undefined ||
      record.emergencyPhone !== undefined
    ))
  );

  return (
    <div className="patient-record-section">
      {record?.isPrivate && (
        <div className="privacy-alert">
          <i className="fas fa-lock"></i>
          <p>This patient has enabled private mode. Some information will be hidden for privacy reasons.</p>
        </div>
      )}

      <div className="record-header">
        <h3>
          {loading ? 'Loading...' : 
           record?.error ? 'Error Loading Record' :
           hasValidRecord ? `${getPatientName()} Medical Record` :
           'Patient Medical Record'}
        </h3>
        {error && (
          <div className="error-banner">
            {error}
          </div>
        )}
        {saveSuccess && (
          <div className="success-banner">
            {saveSuccess}
          </div>
        )}
      </div>

      {loading ? (
        <div className="loading-message">
          <p>Loading patient record... Please wait.</p>
        </div>
      ) : (
        <div className="record-content">
          {/* Profile Image Section - Only show if not hidden */}
          {!hideImage && (
            <div className="profile-image-section">
              <div className="profile-image-container">
                {record?.profileImageBase64 ? (
                  <img
                    src={record.profileImageBase64}
                    alt="Profile"
                    className="profile-image"
                  />
                ) : (
                  <div className="profile-placeholder">
                    <span>No Image</span>
                  </div>
                )}
              </div>
              {isEditable && (
                <div className="image-upload">
                  <input
                    type="file"
                    id="profileImage"
                    accept="image/*"
                    onChange={handleImageUpload}
                    style={{ display: 'none' }}
                    disabled={uploading}
                  />
                  <label 
                    htmlFor="profileImage" 
                    className="upload-btn" 
                    style={{ 
                      opacity: uploading ? 0.6 : 1, 
                      pointerEvents: uploading ? 'none' : 'auto' 
                    }}
                  >
                    {uploading ? 'Uploading...' : 'Upload Photo'}
                  </label>
                  {uploadError && <div className="error-message">{uploadError}</div>}
                  {uploadSuccess && <div className="success-message">{uploadSuccess}</div>}
                </div>
              )}
            </div>
          )}

          <div className="record-container">
            {record?.isPrivate && (
              <div className="privacy-alert">
                <i className="fas fa-lock"></i>
                <p>This patient has enabled private mode. Some information will be hidden for privacy reasons.</p>
              </div>
            )}

            {/* Medical Information Form */}
            <form id="patient-record-form" onSubmit={handleSubmit} className="record-form">
              <div className="form-grid">
                <div className="form-group">
                  <label htmlFor="medicalHistory">Medical History</label>
                  {isEditable ? (
                    <textarea
                      id="medicalHistory"
                      name="medicalHistory"
                      value={formData.medicalHistory}
                      onChange={handleChange}
                      placeholder="Enter medical history..."
                      rows="4"
                    />
                  ) : (
                    <div className="form-display">
                      <SafeText value={formData.medicalHistory} />
                    </div>
                  )}
                </div>

                <div className="form-group">
                  <label htmlFor="allergies">Allergies</label>
                  {isEditable ? (
                    <textarea
                      id="allergies"
                      name="allergies"
                      value={formData.allergies}
                      onChange={handleChange}
                      placeholder="Enter known allergies..."
                      rows="4"
                    />
                  ) : (
                    <div className="form-display">
                      <SafeText value={formData.allergies} />
                    </div>
                  )}
                </div>

                <div className="form-group">
                  <label htmlFor="currentMedications">Current Medications</label>
                  {isEditable ? (
                    <textarea
                      id="currentMedications"
                      name="currentMedications"
                      value={formData.currentMedications}
                      onChange={handleChange}
                      placeholder="Enter current medications..."
                      rows="4"
                    />
                  ) : (
                    <div className="form-display">
                      <SafeText value={formData.currentMedications} />
                    </div>
                  )}
                </div>

                <div className="form-group">
                  <label htmlFor="notes">Additional Notes</label>
                  {isEditable ? (
                    <textarea
                      id="notes"
                      name="notes"
                      value={formData.notes}
                      onChange={handleChange}
                      placeholder="Enter additional notes..."
                      rows="4"
                    />
                  ) : (
                    <div className="form-display">
                      <SafeText value={formData.notes} />
                    </div>
                  )}
                </div>

                <div className="form-group">
                  <label htmlFor="bloodType">Blood Type</label>
                  {isEditable ? (
                    <select
                      id="bloodType"
                      name="bloodType"
                      value={formData.bloodType}
                      onChange={handleChange}
                    >
                      <option value="">Select blood type</option>
                      <option value="A+">A+</option>
                      <option value="A-">A-</option>
                      <option value="B+">B+</option>
                      <option value="B-">B-</option>
                      <option value="AB+">AB+</option>
                      <option value="AB-">AB-</option>
                      <option value="O+">O+</option>
                      <option value="O-">O-</option>
                    </select>
                  ) : (
                    <div className="form-display">
                      <SafeText value={formData.bloodType} />
                    </div>
                  )}
                </div>

                {!record?.isPrivate && (
                  <>
                    <div className="form-group">
                      <label htmlFor="emergencyContact">Emergency Contact</label>
                      {isEditable ? (
                        <input
                          type="text"
                          id="emergencyContact"
                          name="emergencyContact"
                          value={formData.emergencyContact}
                          onChange={handleChange}
                          placeholder="Enter emergency contact name..."
                        />
                      ) : (
                        <div className="form-display">
                          <SafeText value={formData.emergencyContact} />
                        </div>
                      )}
                    </div>

                    <div className="form-group">
                      <label htmlFor="emergencyPhone">Emergency Phone</label>
                      {isEditable ? (
                        <input
                          type="tel"
                          id="emergencyPhone"
                          name="emergencyPhone"
                          value={formData.emergencyPhone}
                          onChange={handleChange}
                          placeholder="Enter emergency phone number..."
                        />
                      ) : (
                        <div className="form-display">
                          <SafeText value={formData.emergencyPhone} />
                        </div>
                      )}
                    </div>
                  </>
                )}

                {isEditable && (
                  <div className="form-actions">
                    <button 
                      type="submit" 
                      className="btn-primary"
                      disabled={loading}
                    >
                      {loading ? (
                        <>
                          <span className="spinner"></span>
                          Saving...
                        </>
                      ) : (
                        'Save Record'
                      )}
                    </button>
                  </div>
                )}
              </div>
            </form>
          </div>
        </div>
      )}
    </div>
  );
};

export default PatientRecordSection;
```

## File: components/arv/ARVTreatmentModal.css
```css
.modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(0, 0, 0, 0.5);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
}

.modal-content {
  background: white;
  padding: 2rem;
  border-radius: 12px;
  width: 90%;
  max-width: 600px;
  max-height: 90vh;
  overflow-y: auto;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
}

.modal-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 1.5rem;
}

.modal-header h3 {
  margin: 0;
  color: #1e293b;
}

.close-btn {
  background: none;
  border: none;
  font-size: 1.5rem;
  cursor: pointer;
  padding: 0.25rem;
  color: #64748b;
}

.close-btn:hover {
  color: #1e293b;
}

.arv-form {
  display: flex;
  flex-direction: column;
  gap: 1rem;
}

.form-row {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 1rem;
}

.form-actions {
  display: flex;
  gap: 1rem;
  margin-top: 1.5rem;
  justify-content: flex-end;
}

.btn-primary {
  background: linear-gradient(135deg, #10b981 0%, #059669 100%);
  color: white;
  border: none;
  padding: 0.75rem 1.5rem;
  border-radius: 8px;
  cursor: pointer;
  font-weight: 600;
  font-size: 1rem;
  transition: all 0.3s ease;
  min-width: 120px;
  box-shadow: 0 2px 4px rgba(16, 185, 129, 0.1);
}

.btn-primary:hover:not(:disabled) {
  background: linear-gradient(135deg, #059669 0%, #047857 100%);
  transform: translateY(-1px);
  box-shadow: 0 4px 12px rgba(16, 185, 129, 0.2);
}

.btn-primary:focus {
  outline: 2px solid #10b981;
  outline-offset: 2px;
  box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.2);
}

.btn-primary:disabled {
  background: #e5e7eb;
  color: #9ca3af;
  cursor: not-allowed;
  transform: none;
  box-shadow: none;
}

.btn-secondary {
  background: #f3f4f6;
  color: #374151;
  border: 2px solid #e5e7eb;
  padding: 0.75rem 1.5rem;
  border-radius: 8px;
  cursor: pointer;
  font-weight: 600;
  font-size: 1rem;
  transition: all 0.3s ease;
  min-width: 120px;
}

.btn-secondary:hover {
  background: #e5e7eb;
  border-color: #d1d5db;
  transform: translateY(-1px);
}

.btn-secondary:focus {
  outline: 2px solid #10b981;
  outline-offset: 2px;
  box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.1);
}
```

## File: components/arv/ARVTreatmentModal.jsx
```jsx
import React, { useState, useEffect } from 'react';
import './ARVTreatmentModal.css';

const ARVTreatmentModal = ({ isOpen, onClose, onSubmit, formData, onChange }) => {
  const [localFormData, setLocalFormData] = useState({
    regimen: '',
    startDate: '',
    endDate: '',
    adherence: '',
    sideEffects: '',
    notes: '',
    setAsTemplate: false
  });
  const [setAsTemplate, setSetAsTemplate] = useState(false);

  useEffect(() => {
    if (formData) {
      setLocalFormData({
        regimen: formData.regimen || '',
        startDate: formData.startDate || '',
        endDate: formData.endDate || '',
        adherence: formData.adherence || '',
        sideEffects: formData.sideEffects || '',
        notes: formData.notes || '',
        setAsTemplate: formData.setAsTemplate || false
      });
      setSetAsTemplate(formData.setAsTemplate || false);
    }
  }, [formData]);

  const handleChange = (e) => {
    const { name, value } = e.target;
    setLocalFormData(prev => ({
      ...prev,
      [name]: value
    }));
    onChange(e);
  };

  const handleCheckbox = (e) => {
    setSetAsTemplate(e.target.checked);
    onChange({ target: { name: 'setAsTemplate', value: e.target.checked } });
    if (e.target.checked) {
      onChange({ target: { name: 'notes', value: 'template' } });
      setLocalFormData(prev => ({ ...prev, notes: 'template' }));
    } else {
      onChange({ target: { name: 'notes', value: '' } });
      setLocalFormData(prev => ({ ...prev, notes: '' }));
    }
  };

  const handleNotesChange = (e) => {
    if (!setAsTemplate) onChange(e);
  };

  const handleSubmit = (e) => {
    e.preventDefault();
    onSubmit({ ...localFormData, setAsTemplate });
  };

  if (!isOpen) return null;

  return (
    <div className="modal-overlay">
      <div className="modal-content">
        <div className="modal-header">
          <h3>{formData ? 'Edit ARV Treatment' : 'Add New ARV Treatment'}</h3>
          <button className="close-btn" onClick={onClose}>Ã—</button>
        </div>

        <form onSubmit={handleSubmit} className="arv-form">
          <div className="form-row">
            <div className="form-group">
              <label>Regimen:</label>
              <input
                type="text"
                name="regimen"
                value={localFormData.regimen}
                onChange={handleChange}
                placeholder="Enter ARV regimen"
                required
              />
            </div>
            <div className="form-group">
              <label>Start Date:</label>
              <input
                type="date"
                name="startDate"
                value={localFormData.startDate}
                onChange={handleChange}
                required
              />
            </div>
          </div>

          <div className="form-row">
            <div className="form-group">
              <label>End Date:</label>
              <input
                type="date"
                name="endDate"
                value={localFormData.endDate}
                onChange={handleChange}
              />
            </div>
            <div className="form-group">
              <label>Adherence:</label>
              <select
                name="adherence"
                value={localFormData.adherence}
                onChange={handleChange}
              >
                <option value="">Select adherence level</option>
                <option value="Excellent">Excellent (95-100%)</option>
                <option value="Good">Good (85-94%)</option>
                <option value="Fair">Fair (75-84%)</option>
                <option value="Poor">Poor (Under 75%)</option>
              </select>
            </div>
          </div>

          <div className="form-group">
            <label>Side Effects:</label>
            <textarea
              name="sideEffects"
              value={localFormData.sideEffects}
              onChange={handleChange}
              rows="3"
              placeholder="Enter any side effects..."
            />
          </div>

          <div className="form-group">
            <label>
              <input
                type="checkbox"
                checked={setAsTemplate}
                onChange={handleCheckbox}
              />{' '}
              Set as template
            </label>
          </div>
          <div className="form-group">
            <label>Notes:</label>
            <textarea
              name="notes"
              value={localFormData.notes}
              onChange={handleNotesChange}
              rows="3"
              placeholder={setAsTemplate ? "Notes will be set as 'template'" : "Enter additional notes..."}
              disabled={setAsTemplate}
              style={setAsTemplate ? { background: '#eee' } : {}}
            />
          </div>

          <div className="form-actions">
            <button type="submit" className="btn-primary">
              {formData ? 'Save Changes' : 'Add Treatment'}
            </button>
            <button type="button" className="btn-secondary" onClick={onClose}>
              Cancel
            </button>
          </div>
        </form>
      </div>
    </div>
  );
};

export default ARVTreatmentModal;
```

## File: components/layout/BackNavigation.css
```css
/* Back Navigation Styles */
.back-navigation {
  display: inline-flex;
  align-items: center;
  gap: 0.5rem;
  padding: 0.5rem 1rem;
  background: white;
  border: 1px solid #e5e7eb;
  border-radius: 8px;
  color: #374151;
  font-size: 0.9rem;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s ease;
  text-decoration: none;
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
}

.back-navigation:hover {
  background: #f9fafb;
  border-color: #d1d5db;
  color: #1f2937;
  transform: translateX(-2px);
}

.back-navigation:focus {
  outline: none;
  border-color: #10b981;
  box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.1);
}

.back-navigation:active {
  transform: translateX(0);
}

.back-navigation svg {
  transition: transform 0.2s ease;
}

.back-navigation:hover svg {
  transform: translateX(-2px);
}

/* Responsive Design */
@media (max-width: 768px) {
  .back-navigation {
    padding: 0.75rem 1rem;
    font-size: 1rem;
  }
}

/* Dark mode support */
@media (prefers-color-scheme: dark) {
  .back-navigation {
    background: #374151;
    border-color: #4b5563;
    color: #d1d5db;
  }
  
  .back-navigation:hover {
    background: #4b5563;
    border-color: #6b7280;
    color: white;
  }
}
```

## File: components/layout/BackNavigation.jsx
```jsx
import { useNavigate, useLocation } from 'react-router-dom';
import './BackNavigation.css';

const BackNavigation = ({ customBack, disabled = false }) => {
  const navigate = useNavigate();
  const location = useLocation();

  // Pages that should not show back navigation
  const noBackPages = [
    '/',
    '/login',
    '/register',
    '/admin',
    '/doctor',
    '/customer'
  ];

  const shouldShowBack = !noBackPages.includes(location.pathname) && !disabled;

  const handleBack = () => {
    if (customBack) {
      customBack();
    } else {
      navigate(-1);
    }
  };

  if (!shouldShowBack) {
    return null;
  }

  return (
    <button 
      className="back-navigation"
      onClick={handleBack}
      aria-label="Go back"
    >
      <svg 
        width="20" 
        height="20" 
        viewBox="0 0 24 24" 
        fill="none"
      >
        <path 
          d="M19 12H5m7-7l-7 7 7 7" 
          stroke="currentColor" 
          strokeWidth="2" 
          strokeLinecap="round" 
          strokeLinejoin="round"
        />
      </svg>
      Back
    </button>
  );
};

export default BackNavigation;
```

## File: components/layout/DashboardHeader.jsx
```jsx
import { useAuth } from '../../contexts/useAuth';
import UserProfileDropdown from './UserProfileDropdown';
import { useEffect, useState, useCallback } from 'react';
import apiClient from '../../services/apiClient';
import notificationService from '../../services/notificationService';
import NotificationIcon from '../notifications/NotificationIcon';
import NotificationPanel from '../notifications/NotificationPanel';
import './DashboardHeader.css';

const DashboardHeader = ({ title, subtitle }) => {
  const { user } = useAuth();
  const [currentDateTime, setCurrentDateTime] = useState(new Date());
  const [isPrivate, setIsPrivate] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState(null);
  const [notifications, setNotifications] = useState([]);
  const [unreadCount, setUnreadCount] = useState(0);
  const [showPanel, setShowPanel] = useState(false);

  // Function to check if user is a patient
  const isPatient = useCallback(() => {
    return user && (user.role === 'Patient' || user?.role?.roleName === 'Patient');
  }, [user]);

  // Handle notification updates from the service
  const handleNotificationUpdate = useCallback((notificationData, isNewNotifications) => {
    setNotifications(notificationData);
    setUnreadCount(notificationData.filter(n => !n.isRead).length);
    
    // Only log when new notifications are received
    if (isNewNotifications) {
      console.log('New notifications received:', notificationData.filter(n => !n.isRead).length);
    }
  }, []);

  // Separate useEffect for clock timer
  useEffect(() => {
    const timer = setInterval(() => {
      setCurrentDateTime(new Date());
    }, 1000);

    return () => clearInterval(timer);
  }, []);

  // Separate useEffect for initial data loading
  useEffect(() => {
    const loadPrivateMode = async () => {
      if (isPatient()) {
        try {
          const response = await apiClient.get('/patients/privacy-settings');
          const privacyState = response.data?.isPrivate ?? false;
          setIsPrivate(privacyState);
          sessionStorage.setItem('privateMode', JSON.stringify(privacyState));
        } catch (error) {
          console.error('Failed to load privacy settings:', error);
          setError('Failed to load privacy settings');
          // Fallback to localStorage if API fails
          const savedMode = sessionStorage.getItem('privateMode');
          if (savedMode) {
            setIsPrivate(JSON.parse(savedMode));
          }
        }
      }
    };

    loadPrivateMode();
  }, [isPatient]);

  // Separate useEffect for notification management
  useEffect(() => {
    if (!user) return;

    // Initial fetch of notifications on login
    const initializeNotifications = async () => {
      await notificationService.getInitialNotifications();
    };

    initializeNotifications();

    // Subscribe to notification updates
    const unsubscribe = notificationService.subscribeToNotifications(handleNotificationUpdate);

    return () => {
      unsubscribe();
    };
  }, [user, handleNotificationUpdate]);

  // Reset notification state on logout
  useEffect(() => {
    if (!user) {
      notificationService.resetPollingState();
      setNotifications([]);
      setUnreadCount(0);
    }
  }, [user]);

  const togglePrivacy = async () => {
    if (!isPatient() || isLoading) return;
    
    setIsLoading(true);
    setError(null);
    
    try {
      const newState = !isPrivate;
      
      // Update UI state immediately for better user feedback
      setIsPrivate(newState);
        // Make API call
        const response = await apiClient.post('/patients/privacy-settings', {
          isPrivate: newState
        });
      
      if (!response.data?.success) {
        throw new Error(response.data?.message || 'Failed to update privacy settings');
      }
      
      // Update sessionStorage after successful API call
      sessionStorage.setItem('privateMode', JSON.stringify(newState));
      
    } catch (error) {
      console.error('Failed to update privacy settings:', error);
      setError('Failed to update privacy mode');
      // Revert the UI state if the API call failed
      const savedMode = localStorage.getItem('privateMode');
      if (savedMode) {
        setIsPrivate(JSON.parse(savedMode));
      }
    } finally {
      setIsLoading(false);
    }
  };

  const handleMarkAsRead = async (notificationId) => {
    // Store original state in case we need to revert
    const originalNotifications = [...notifications];
    const originalUnreadCount = unreadCount;
    
    // Optimistically update the UI
    setNotifications(notifications.map(n => n.notificationId === notificationId ? { ...n, isRead: true, status: 'READ' } : n));
    setUnreadCount(Math.max(0, unreadCount - 1));
    
    try {
        const result = await notificationService.markAsRead(notificationId);
        
        if (!result.success) {
            console.error('Failed to mark notification as read:', result.error);
            // Revert the UI changes if API call failed
            setNotifications(originalNotifications);
            setUnreadCount(originalUnreadCount);
        }
    } catch (error) {
        console.error('Exception in handleMarkAsRead:', error);
        // Revert the UI changes if API call failed
        setNotifications(originalNotifications);
        setUnreadCount(originalUnreadCount);
    }
  };

  const _handleMarkAllAsRead = async () => {
    try {
      const result = await notificationService.markAllAsRead();
      
      if (result.success) {
        console.log('Successfully marked all notifications as read');
        // Update UI state after successful API call
        setNotifications(notifications.map(n => ({ ...n, isRead: true, status: 'READ' })));
        setUnreadCount(0);
      } else {
        console.error('Failed to mark all notifications as read:', result.error);
        setError('Failed to mark notifications as read');
      }
    } catch (error) {
      console.error('Exception marking all notifications as read:', error);
      setError('Failed to mark notifications as read');
    }
  };

  const formatDateTime = () => {
    const dateOptions = {
      weekday: 'short',
      year: 'numeric',
      month: 'short',
      day: 'numeric'
    };
    const timeOptions = {
      hour: '2-digit',
      minute: '2-digit',
      hour12: false
    };
    const date = currentDateTime.toLocaleDateString('en-GB', dateOptions);
    const time = currentDateTime.toLocaleTimeString('en-GB', timeOptions);
    return { date, time };
  };
  const { date, time } = formatDateTime();

  return (
    <div className="dashboard-header">
      <div className="dashboard-header-content">
        <div className="dashboard-header-info">
          <span
            className="nav-logo"
            tabIndex={0}
            onClick={() => window.location.pathname = '/'}
            onKeyDown={e => { if (e.key === 'Enter' || e.key === ' ') window.location.pathname = '/'; }}
          >
            <span className="logo-icon">
              <svg viewBox="0 0 24 24" fill="currentColor" width="28" height="28">
                <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1 17.93c-3.94-.49-7-3.85-7-7.93 0-.62.08-1.21.21-1.79L9 15v1c0 1.1.9 2 2 2v1.93zm6.9-2.54c-.26-.81-1-1.39-1.9-1.39h-1v-3c0-.55-.45-1-1-1H8v-2h2c.55 0 1-.45 1-1V7h2c1.1 0 2-.9 2-2v-.41c2.93 1.19 5 4.06 5 7.41 0 2.08-.8 3.97-2.1 5.39z"/>
              </svg>
            </span>
            <span className="logo-text">HIV Medical System</span>
          </span>
          <div className="dashboard-header-titles">
            <h1 className="dashboard-title">{title}</h1>
            {subtitle && <p className="dashboard-subtitle">{subtitle}</p>}
          </div>
        </div>
          <div className="dashboard-header-actions">
          {isPatient() && (
            <button 
              className={`privacy-toggle ${isPrivate ? 'active' : ''} ${isLoading ? 'loading' : ''}`}
              onClick={togglePrivacy}
              disabled={isLoading}
              title={error || `Turn ${isPrivate ? 'off' : 'on'} privacy mode`}
              role="switch"
              aria-checked={isPrivate}
              type="button"
            >
              <span className="icon">
                {isPrivate ? (
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                    <rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect>
                    <path d="M7 11V7a5 5 0 0110 0v4"></path>
                  </svg>
                ) : (
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                    <rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect>
                    <path d="M7 11V7a5 5 0 0110 0v4"></path>
                    <line x1="12" y1="15" x2="12" y2="18"></line>
                  </svg>
                )}
              </span>
              {isPrivate ? 'Anonymous' : 'Public'}
            </button>
          )}
          <div className="system-datetime">
            <div className="date">{date}</div>
            <div className="time">{time}</div>
          </div>
          <NotificationIcon count={unreadCount} onClick={async () => {
            // ALWAYS mark all notifications as read when notification button is clicked
            console.log('Notification button clicked - marking all as read');
            
            try {
              // Wait for API response before updating UI
              const result = await notificationService.markAllAsRead();
              
              if (result.success) {
                console.log('Successfully marked all notifications as read');
                // Update UI state immediately after successful API call
                setNotifications(notifications.map(n => ({ ...n, isRead: true, status: 'READ' })));
                setUnreadCount(0);
              } else {
                console.error('Failed to mark all notifications as read:', result.error);
                // Show error feedback to user
                setError('Failed to mark notifications as read');
              }
            } catch (error) {
              console.error('Exception marking all notifications as read:', error);
              setError('Failed to mark notifications as read');
            }
            
            // Show panel after marking as read
            setShowPanel(!showPanel);
          }} />
          {showPanel && (
            <NotificationPanel
              notifications={notifications}
              onMarkAsRead={handleMarkAsRead}
              onClose={() => setShowPanel(false)}
            />
          )}
          <UserProfileDropdown />
        </div>
      </div>
    </div>
  );
};

export default DashboardHeader;
```

## File: components/layout/DashboardHeader.css
```css
/* Dashboard Header Styles */
.dashboard-header {
  background: linear-gradient(135deg, #e6f9f0 0%, #f3fdf7 100%);
  border-bottom: 1px solid #e5e7eb;
  padding: 1rem 2rem;
  position: sticky;
  top: 0;
  left: 0;
  right: 0;
  width: 100%;
  z-index: 100;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
}

.dashboard-header-content {
  display: flex;
  justify-content: space-between;
  align-items: center;
  max-width: 100%;
  margin: 0 auto;
  width: 100%;
}

.dashboard-header-info {
  flex: 1;
  min-width: 0;
  display: flex;
  align-items: center; /* changed from flex-start to center */
  gap: 1rem;
}

.dashboard-header-info .nav-logo {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  cursor: pointer;
  text-decoration: none;
  color: #10b981;
  font-weight: 700;
  font-size: 1.1rem;
}

.dashboard-header-titles {
  display: flex;
  flex-direction: row; /* changed from column to row */
  align-items: center;
  gap: 0.75rem;
  margin: 0;
}

.dashboard-title {
  font-size: 1.5rem;
  font-weight: 700;
  color: #10b981;
  margin: 0;
  line-height: 1.2;
  text-align: left;
  display: inline-block;
}

.dashboard-subtitle {
  font-size: 0.9rem;
  color: #374151;
  margin: 0.25rem 0 0;
  line-height: 1.4;
  text-align: left;
}

.dashboard-header-actions {
  display: flex;
  align-items: center;
  gap: 1rem;
  flex-shrink: 0;
}

.privacy-toggle {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  padding: 0.5rem 1rem;
  border: 1px solid #e5e7eb;
  border-radius: 2rem;
  background: white;
  color: #374151;
  font-size: 0.875rem;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s ease;
}

.privacy-toggle:hover {
  color:#f3fdf7;
  background: #f9fafb;
  border-color: #10b981;
}

.privacy-toggle.active {
  background: #10b981;
  border-color: #059669;
  color: white;
}

.privacy-toggle.loading {
  opacity: 0.7;
  cursor: not-allowed;
}

.privacy-toggle svg {
  width: 1.25rem;
  height: 1.25rem;
}

/* System DateTime Styles */
.system-datetime {
  display: flex;
  flex-direction: column;
  align-items: flex-end;
  gap: 0.125rem;
  margin-right: 0.75rem;
}

.system-datetime .date {
  font-size: 0.875rem;
  font-weight: 600;
  color: #374151;
  line-height: 1.2;
}

.system-datetime .time {
  font-size: 0.75rem;
  font-weight: 500;
  color: #64748b;
  line-height: 1.2;
}

/* Responsive Design */
@media (max-width: 768px) {
  .dashboard-header {
    padding: 1rem;
  }

  .dashboard-header-content {
    flex-direction: column;
    align-items: flex-start;
    gap: 1rem;
  }

  .dashboard-header-actions {
    width: 100%;
    justify-content: flex-end;
  }

  .dashboard-title {
    font-size: 1.25rem;
  }

  .dashboard-subtitle {
    font-size: 0.85rem;
  }

  /* Adjust spacing for mobile */
  .admin-dashboard-layout,
  .doctor-dashboard-layout,
  .customer-dashboard-layout {
    margin-top: 120px; /* Increased space for expanded header on mobile */
  }
}

@media (max-width: 480px) {
  .dashboard-header {
    padding: 0.75rem;
  }

  .dashboard-title {
    font-size: 1.125rem;
  }

  /* Further adjust spacing for smaller screens */
  .admin-dashboard-layout,
  .doctor-dashboard-layout,
  .customer-dashboard-layout {
    margin-top: 140px; /* More space for even more expanded header */
  }
}
```

## File: utils/dateUtils.js
```js
/**
 * Enhanced utility functions for date formatting and validation
 */

/**
 * Format date and time for API requests with enhanced error handling
 * @param {string|Date|Object} date - The date in various formats
 * @param {string|Date|Object} time - The time in various formats
 * @returns {string} - Formatted datetime string for API
 */
export const formatDateTimeForAPI = (date, time) => {
  try {
    if (!date) {
      throw new Error('Date is required');
    }

    let dateStr;
    let timeStr;

    // Handle date parameter
    if (date instanceof Date) {
      if (isNaN(date.getTime())) {
        throw new Error('Invalid Date object');
      }
      dateStr = date.toISOString().split('T')[0]; // YYYY-MM-DD format
    } else if (typeof date === 'string') {
      // Check if already in YYYY-MM-DD format
      if (/^\d{4}-\d{2}-\d{2}$/.test(date)) {
        dateStr = date;
      } else {
        // Try to parse and format
        const parsedDate = new Date(date);
        if (isNaN(parsedDate.getTime())) {
          throw new Error('Invalid date format');
        }
        dateStr = parsedDate.toISOString().split('T')[0];
      }
    } else if (date && typeof date === 'object') {
      // Handle slot date objects that might have nested date properties
      if (date.slotDate) {
        return formatDateTimeForAPI(date.slotDate, time);
      } else if (date.date) {
        return formatDateTimeForAPI(date.date, time);
      } else {
        throw new Error('Invalid date object structure');
      }
    } else {
      throw new Error('Date must be a Date object or string');
    }

    // Handle time parameter - ENSURE SECONDS ARE ALWAYS INCLUDED
    if (!time) {
      timeStr = '00:00:00'; // Default to midnight if no time provided
    } else if (typeof time === 'string') {
      // Handle various time formats and ALWAYS ensure HH:mm:ss format
      if (/^\d{2}:\d{2}:\d{2}$/.test(time)) {
        timeStr = time; // Already in HH:mm:ss format
      } else if (/^\d{2}:\d{2}$/.test(time)) {
        timeStr = time + ':00'; // Add seconds
      } else if (/^\d{1,2}:\d{2}$/.test(time)) {
        // Handle single digit hours like "9:00"
        const [hours, minutes] = time.split(':');
        timeStr = hours.padStart(2, '0') + ':' + minutes + ':00';
      } else if (/^\d{4}$/.test(time)) {
        // Handle HHMM format
        timeStr = time.substring(0, 2) + ':' + time.substring(2) + ':00';
      } else if (/^\d{1,2}$/.test(time)) {
        // Handle hour only like "9" or "14"
        timeStr = time.padStart(2, '0') + ':00:00';
      } else {
        throw new Error('Invalid time format. Expected HH:mm:ss, HH:mm, or HHMM');
      }
    } else if (time instanceof Date) {
      const hours = time.getHours().toString().padStart(2, '0');
      const minutes = time.getMinutes().toString().padStart(2, '0');
      const seconds = time.getSeconds().toString().padStart(2, '0');
      timeStr = `${hours}:${minutes}:${seconds}`;
    } else if (time && typeof time === 'object') {
      // Handle time objects that might have nested time properties
      if (time.startTime) {
        return formatDateTimeForAPI(date, time.startTime);
      } else if (time.time) {
        return formatDateTimeForAPI(date, time.time);
      } else {
        throw new Error('Invalid time object structure');
      }
    } else {
      throw new Error('Time must be a string or Date object');
    }

    // Ensure the final format is exactly YYYY-MM-DDTHH:mm:ss
    const result = `${dateStr}T${timeStr}`;
    
    // Validate the final format
    if (!/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}$/.test(result)) {
      throw new Error(`Invalid final format: ${result}. Expected YYYY-MM-DDTHH:mm:ss`);
    }

    console.log(`Formatted date/time: ${result}`);
    return result;

  } catch (error) {
    console.error('Error formatting date/time for API:', error);
    console.error('Input date:', date);
    console.error('Input time:', time);
    throw new Error(`Failed to format date/time: ${error.message}`);
  }
};

/**
 * Format a single datetime value for API requests
 * @param {Date|string|Object} dateTime - The datetime value
 * @returns {string} - Formatted datetime string for API
 */
export const formatSingleDateTimeForAPI = (dateTime) => {
  try {
    if (!dateTime) {
      throw new Error('DateTime is required');
    }

    if (dateTime instanceof Date) {
      const isoString = dateTime.toISOString();
      // Remove milliseconds and Z, ensure format is YYYY-MM-DDTHH:mm:ss
      return isoString.replace(/\.\d{3}Z$/, '');
    }

    if (typeof dateTime === 'string') {
      // Handle ISO string format
      if (dateTime.includes('T')) {
        // Remove milliseconds and Z if present
        let cleaned = dateTime.replace(/\.\d{3}Z?$/, '').replace('Z', '');
        // Ensure seconds are present
        if (/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}$/.test(cleaned)) {
          cleaned += ':00';
        }
        return cleaned;
      }
      // Handle YYYY-MM-DD format (assume midnight)
      if (/^\d{4}-\d{2}-\d{2}$/.test(dateTime)) {
        return `${dateTime}T00:00:00`;
      }
    }

    if (typeof dateTime === 'object') {
      // Handle objects with date and time properties
      if (dateTime.date && dateTime.time) {
        return formatDateTimeForAPI(dateTime.date, dateTime.time);
      }
      if (dateTime.slotDate && dateTime.startTime) {
        return formatDateTimeForAPI(dateTime.slotDate, dateTime.startTime);
      }
    }

    throw new Error('Unsupported datetime format');
  } catch (error) {
    console.error('Error formatting single datetime for API:', error);
    throw new Error(`Failed to format datetime: ${error.message}`);
  }
};

/**
 * Safely format a date value for display
 * @param {Date|string} dateValue - The date value to format
 * @returns {string} - Formatted date string or empty string if invalid
 */
export const safeFormatDate = (dateValue) => {
  try {
    if (!dateValue) return '';
    
    if (dateValue instanceof Date) {
      return dateValue.toLocaleDateString();
    }
    
    if (typeof dateValue === 'string') {
      const date = new Date(dateValue);
      if (!isNaN(date.getTime())) {
        return date.toLocaleDateString();
      }
    }
    
    return '';
  } catch (error) {
    console.warn('Error formatting date:', error);
    return '';
  }
};

/**
 * Safely format a time value for display
 * @param {string|Date} timeValue - The time value to format
 * @returns {string} - Formatted time string or empty string if invalid
 */
export const safeFormatTime = (timeValue) => {
  try {
    if (!timeValue) return '';
    
    if (typeof timeValue === 'string') {
      // Handle time strings like "14:30:00" or "14:30"
      const timeParts = timeValue.split(':');
      if (timeParts.length >= 2) {
        const hours = parseInt(timeParts[0]);
        const minutes = parseInt(timeParts[1]);
        
        if (!isNaN(hours) && !isNaN(minutes)) {
          const date = new Date();
          date.setHours(hours, minutes, 0, 0);
          return date.toLocaleTimeString('en-US', { 
            hour: 'numeric', 
            minute: '2-digit',
            hour12: true 
          });
        }
      }
    }
    
    if (timeValue instanceof Date) {
      return timeValue.toLocaleTimeString('en-US', { 
        hour: 'numeric', 
        minute: '2-digit',
        hour12: true 
      });
    }
    
    return '';
  } catch (error) {
    console.warn('Error formatting time:', error);
    return '';
  }
};

/**
 * Validate appointment booking data
 * @param {Object} bookingData - The booking data to validate
 * @returns {Object} - Validation result with isValid and errors
 */
export const validateBookingData = (bookingData) => {
  const errors = [];

  if (!bookingData.doctorUserId) {
    errors.push('Doctor ID is required');
  }

  if (!bookingData.availabilitySlotId) {
    errors.push('Availability slot ID is required');
  }

  if (!bookingData.appointmentDateTime) {
    errors.push('Appointment date and time is required');
  } else {
    // Validate datetime format - MUST be exactly YYYY-MM-DDTHH:mm:ss
    const datetimeRegex = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}$/;
    if (!datetimeRegex.test(bookingData.appointmentDateTime)) {
      errors.push(`Invalid appointment date/time format. Expected: YYYY-MM-DDTHH:mm:ss, got: ${bookingData.appointmentDateTime}`);
    }
  }

  if (!bookingData.durationMinutes || bookingData.durationMinutes < 1) {
    errors.push('Valid duration is required');
  }

  return {
    isValid: errors.length === 0,
    errors
  };
};

/**
 * Create a booking data object with proper formatting
 * @param {Object} slotData - The slot data
 * @param {number} doctorUserId - The doctor's user ID
 * @returns {Object} - Properly formatted booking data
 */
export const createBookingData = (slotData, doctorUserId) => {
  try {
    if (!slotData || !doctorUserId) {
      throw new Error('Slot data and doctor ID are required');
    }

    // Extract date and time components
    const dateStr = slotData.slotDate || slotData.date || (slotData.appointmentDateTime || '').split('T')[0];
    const timeStr = slotData.startTime || slotData.time || (slotData.appointmentDateTime || '').split('T')[1];

    if (!dateStr || !timeStr) {
      throw new Error('Cannot extract date and time from slot data');
    }

    const appointmentDateTime = formatDateTimeForAPI(dateStr, timeStr);

    return {
      doctorUserId,
      availabilitySlotId: slotData.availabilitySlotId,
      appointmentDateTime,
      durationMinutes: slotData.durationMinutes || 30
    };
  } catch (error) {
    console.error('Error creating booking data:', error);
    throw error;
  }
};

export const formatTimeForAPI = (time) => {
  if (!time) return null;
  // Ensure time is in HH:mm:ss format
  return time.includes(':') ? 
    (time.length === 5 ? `${time}:00` : time) : 
    `${time.substring(0, 2)}:${time.substring(2, 4)}:00`;
};

export const formatDateForAPI = (date) => {
  if (!date) return null;
  if (typeof date === 'string' && /^\d{4}-\d{2}-\d{2}$/.test(date)) {
    return date;
  }
  try {
    const d = new Date(date);
    return d.toISOString().split('T')[0];
  } catch (error) {
    console.error('Error formatting date:', error);
    return null;
  }
};
```

## File: utils/imageUtils.js
```js
/**
 * Crops an image to a square (512x512) with center cropping
 * @param {File} file - The image file to crop
 * @returns {Promise<string>} - Base64 encoded cropped image
 */
export const cropImageToSquare = (file) => {
  return new Promise((resolve, reject) => {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const img = new Image();
    
    img.onload = () => {
      // Set canvas size to 512x512
      canvas.width = 512;
      canvas.height = 512;
      
      // Calculate crop dimensions for center crop
      const size = Math.min(img.width, img.height);
      const startX = (img.width - size) / 2;
      const startY = (img.height - size) / 2;
      
      // Draw the cropped image
      ctx.drawImage(
        img,
        startX, startY, size, size, // Source rectangle (center crop)
        0, 0, 512, 512 // Destination rectangle (512x512)
      );
      
      // Convert to base64
      const base64 = canvas.toDataURL('image/jpeg', 0.8);
      resolve(base64);
    };
    
    img.onerror = () => {
      reject(new Error('Failed to load image'));
    };
    
    // Create object URL for the image
    img.src = URL.createObjectURL(file);
  });
};

/**
 * Validates image file before processing
 * @param {File} file - The file to validate
 * @returns {boolean} - Whether the file is a valid image
 */
export const validateImageFile = (file) => {
  if (!file) return false;
  
  // Check file type
  const validTypes = ['image/jpeg', 'image/jpg', 'image/png', 'image/gif'];
  if (!validTypes.includes(file.type)) {
    throw new Error('Please select a valid image file (JPEG, PNG, or GIF)');
  }
  
  // Check file size (max 10MB)
  const maxSize = 10 * 1024 * 1024; // 10MB
  if (file.size > maxSize) {
    throw new Error('Image file size must be less than 10MB');
  }
  
  return true;
};
```

## File: utils/renderUtils.js
```js
import React from 'react';

/**
 * Enhanced utility functions for safe rendering of data
 */

/**
 * Safely renders a value, handling null, undefined, and object cases
 * @param {any} value - The value to render
 * @param {string} fallback - Fallback value if the input is null/undefined
 * @returns {string} - Safe string representation
 */
export const safeRender = (value) => {
  if (value === null || value === undefined) {
    return '';
  }
  
  if (typeof value === 'object') {
    // Handle Date objects
    if (value instanceof Date) {
      return value.toLocaleDateString();
    }
    
    // Handle arrays
    if (Array.isArray(value)) {
      return value.join(', ');
    }
    
    // For other objects, try to extract meaningful data
    if (value.toString && typeof value.toString === 'function') {
      const stringValue = value.toString();
      if (stringValue !== '[object Object]') {
        return stringValue;
      }
    }
    
    // Last resort: JSON stringify
    try {
      return JSON.stringify(value);
    } catch (error) {
      console.warn('Error stringifying object:', error);
      return '[Complex Object]';
    }
  }
  
  return String(value);
};

/**
 * Safely renders a date value
 * @param {any} dateValue - The date value to render
 * @param {string} fallback - Fallback value if the input is null/undefined
 * @returns {string} - Formatted date string
 */
export const safeDate = (dateValue) => {
  if (!dateValue) return '';
  
  try {
    let date;
    
    if (dateValue instanceof Date) {
      date = dateValue;
    } else if (typeof dateValue === 'string') {
      date = new Date(dateValue);
    } else if (Array.isArray(dateValue) && dateValue.length >= 3) {
      // Handle [year, month, day] format
      date = new Date(dateValue[0], dateValue[1] - 1, dateValue[2]);
    } else {
      return safeRender(dateValue);
    }
    
    if (isNaN(date.getTime())) {
      return 'Invalid Date';
    }
    
    return date.toLocaleDateString();
  } catch (error) {
    console.warn('Error formatting date:', dateValue, error);
    return safeRender(dateValue);
  }
};

/**
 * Safely renders a date and time value
 * @param {any} dateTimeValue - The datetime value to render
 * @param {string} fallback - Fallback value if the input is null/undefined
 * @returns {string} - Formatted datetime string
 */
export const safeDateTime = (dateTimeValue) => {
  if (!dateTimeValue) return '';
  
  try {
    const date = new Date(dateTimeValue);
    
    if (isNaN(date.getTime())) {
      return 'Invalid Date';
    }
    
    return date.toLocaleString();
  } catch (error) {
    console.warn('Error formatting datetime:', dateTimeValue, error);
    return safeRender(dateTimeValue);
  }
};

/**
 * Safely renders a time value
 * @param {any} timeValue - The time value to render
 * @param {string} fallback - Fallback value if the input is null/undefined
 * @returns {string} - Formatted time string
 */
export const safeTime = (timeValue) => {
  if (!timeValue) return '';
  
  try {
    // Handle time strings like "14:30:00" or "14:30"
    if (typeof timeValue === 'string') {
      const timeParts = timeValue.split(':');
      if (timeParts.length >= 2) {
        const hours = parseInt(timeParts[0]);
        const minutes = parseInt(timeParts[1]);
        
        if (!isNaN(hours) && !isNaN(minutes)) {
          const date = new Date();
          date.setHours(hours, minutes, 0, 0);
          return date.toLocaleTimeString('en-US', { 
            hour: 'numeric', 
            minute: '2-digit',
            hour12: true 
          });
        }
      }
    }
    
    // Handle Date objects
    if (timeValue instanceof Date) {
      return timeValue.toLocaleTimeString('en-US', { 
        hour: 'numeric', 
        minute: '2-digit',
        hour12: true 
      });
    }
    
    // Try to parse as date
    const date = new Date(timeValue);
    if (!isNaN(date.getTime())) {
      return date.toLocaleTimeString('en-US', { 
        hour: 'numeric', 
        minute: '2-digit',
        hour12: true 
      });
    }
    
    return 'Invalid Time';
  } catch (error) {
    console.warn('Error formatting time:', timeValue, error);
    return safeRender(timeValue);
  }
};

/**
 * Safely renders user information
 * @param {any} user - The user object to render
 * @param {string} fallback - Fallback value if the input is null/undefined
 * @returns {string} - User display name
 */
export const safeUser = (user, fallback = 'N/A') => {
  if (!user) return fallback;
  
  if (typeof user === 'string') return user;
  
  if (typeof user === 'object') {
    // Handle nested user objects
    const userObj = user.user || user;
    
    // Try different combinations of name fields
    if (userObj.firstName && userObj.lastName) {
      return `${userObj.firstName} ${userObj.lastName}`;
    }
    if (userObj.username) return userObj.username;
    if (userObj.name) return userObj.name;
    if (userObj.displayName) return userObj.displayName;
    if (userObj.email) return userObj.email;
  }
  
  return fallback;
};

/**
 * Safely renders role information
 * @param {any} role - The role object to render
 * @param {string} fallback - Fallback value if the input is null/undefined
 * @returns {string} - Role name
 */
export const safeRole = (role, fallback = 'N/A') => {
  if (!role) return fallback;
  
  if (typeof role === 'string') return role;
  
  if (typeof role === 'object') {
    // Handle nested role objects
    const roleObj = role.role || role;
    
    if (roleObj.roleName) return roleObj.roleName;
    if (roleObj.name) return roleObj.name;
  }
  
  return fallback;
};

/**
 * Safely renders status with proper capitalization
 * @param {any} status - The status to render
 * @param {string} fallback - Fallback value if the input is null/undefined
 * @returns {string} - Formatted status
 */
export const safeStatus = (status, fallback = 'N/A') => {
  if (!status) return fallback;
  
  const statusStr = String(status);
  return statusStr.charAt(0).toUpperCase() + statusStr.slice(1).toLowerCase();
};

export const debugObject = (obj, label = 'Object') => {
  console.group(`Debug: ${label}`);
  console.log('Type:', typeof obj);
  console.log('Value:', obj);
  console.log('Constructor:', obj?.constructor?.name);
  console.log('Keys:', obj && typeof obj === 'object' ? Object.keys(obj) : 'N/A');
  console.groupEnd();
  return obj;
};
```

## File: utils/SafeComponents.jsx
```jsx
import React from 'react';
import { 
  safeRender, 
  safeDate, 
  safeDateTime, 
  safeTime, 
  safeUser, 
  safeRole, 
  safeStatus 
} from './renderUtils';

/**
 * Safe text component for React
 */
export const SafeText = ({ children, fallback = 'N/A', className = '' }) => {
  const safeValue = React.useMemo(() => {
    if (children === null || children === undefined) return fallback;
    if (typeof children === 'string' && children.trim() === '') return fallback;
    return children.toString();
  }, [children, fallback]);

  return <span className={className}>{safeValue}</span>;
};

/**
 * Safe date component for React
 */
export const SafeDate = ({ children, fallback = 'N/A', className = '' }) => {
  const safeValue = safeDate(children, fallback);
  return <span className={className}>{safeValue}</span>;
};

/**
 * Safe datetime component for React
 */
export const SafeDateTime = ({ children, fallback = 'N/A', className = '' }) => {
  const safeValue = safeDateTime(children, fallback);
  return <span className={className}>{safeValue}</span>;
};

/**
 * Safe time component for React
 */
export const SafeTime = ({ children, fallback = 'N/A', className = '' }) => {
  const safeValue = safeTime(children, fallback);
  return <span className={className}>{safeValue}</span>;
};

/**
 * Safe user component for React
 */
export const SafeUser = ({ children, fallback = 'N/A', className = '' }) => {
  const safeValue = safeUser(children, fallback);
  return <span className={className}>{safeValue}</span>;
};

/**
 * Safe role component for React
 */
export const SafeRole = ({ children, fallback = 'N/A', className = '' }) => {
  const safeValue = safeRole(children, fallback);
  return <span className={className}>{safeValue}</span>;
};

/**
 * Safe status component for React
 */
export const SafeStatus = ({ children, fallback = 'N/A', className = '' }) => {
  const safeValue = safeStatus(children, fallback);
  return <span className={className}>{safeValue}</span>;
};

/**
 * Generic safe component for any value
 */
export const Safe = ({ value, fallback = 'N/A', className = '', type = 'text' }) => {
  let safeValue;
  
  switch (type) {
    case 'date':
      safeValue = safeDate(value, fallback);
      break;
    case 'datetime':
      safeValue = safeDateTime(value, fallback);
      break;
    case 'time':
      safeValue = safeTime(value, fallback);
      break;
    case 'user':
      safeValue = safeUser(value, fallback);
      break;
    case 'role':
      safeValue = safeRole(value, fallback);
      break;
    case 'status':
      safeValue = safeStatus(value, fallback);
      break;
    default:
      safeValue = safeRender(value, fallback);
  }
  
  return <span className={className}>{safeValue}</span>;
};

export default {
  SafeText,
  SafeDate,
  SafeDateTime,
  SafeTime,
  SafeUser,
  SafeRole,
  SafeStatus,
  Safe
};
```

---
